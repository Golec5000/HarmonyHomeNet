\chapter{Implementacja}
%W tej części pracy zostanie omówiona implementacja systemu eBOKa „Harmony Home Net”. 
Proces implementacji polega na przełożeniu założeń architektonicznych, wymagań funkcjonalnych oraz niefunkcjonalnych na działający kod, a także integracji poszczególnych komponentów systemu w spójną całość. W przypadku systemu eBOKa „Harmony Home Net” proces ten obejmuje zarówno warstwę frontendową, odpowiadającą za interakcje użytkowników, jak i backend, zajmujący się logiką biznesową i zarządzaniem danymi. Kluczowym elementem implementacji jest integracja z bazą danych PostgreSQL uruchomioną w środowisku Docker.

% TO DO: praca wymaga poprawek stylistycznych. Niektóre zdania są "zbyt pompatyczne", czasem też niegramatyczne.
Warto podkreślić, że obecnie system „Harmony Home Net” ma charakter prototypu. Pozwala on na walidację podstawowych założeń oraz funkcji aplikacji eBOK, jednocześnie stanowiąc fundament dla przyszłego rozwoju pełnoprawnej aplikacji produkcyjnej. Zastosowane technologie, takie jak Next.js dla frontendu, Spring Boot dla backendu oraz Docker dla konteneryzacji, zapewniają skalowalność oraz łatwość rozbudowy systemu w kolejnych etapach.

Rozdział rozpocznie omówienie zastosowanej \textbf{architektury warstwowej}~\cite{n_tier_wiki}, która jest podstawą projektowanego systemu. Szczegółowo opisane zostaną wszystkie warstwy – prezentacji, logiki biznesowej oraz dostępu do danych – z uwzględnieniem ich ról oraz sposobu implementacji. Następnie uwaga zostanie zwrócona na \textbf{bazę danych}. Omówione zostaną podejścia \emph{Database First} i \emph{Code First}, wraz z uzasadnieniem wyboru pierwszego z nich. Podane zostaną szczegóły zaprojektowanej struktury bazy danych oraz sposób jej integracji z aplikacją.

Przegląd kluczowych elementów systemu związanych z \textbf{bezpieczeństwem} obejmie mechanizmy autoryzacji i uwierzytelniania, zrealizowane za pomocą Spring Security. Następnie zostanie opisane \textbf{zarządzanie użytkownikami systemu}, a także inne istotne funkcje, jak zarządzanie mieszkaniami, zgłoszeniami technicznymi, płatnościami i powiadomieniami.


% TO DO: czy rzeczywiście wdrożenia? Wdrożenie to proces instalacji i uruchomienia aplikacji w środowisku produkcyjnym.
%        lekko przeredagowując można poniższe zdania przenieść do Układu pracy
%Celem tej części pracy jest nie tylko opisanie kroków wdrożenia, ale również ukazanie, w jaki sposób zaimplementowane rozwiązania odpowiadają na postawione wymagania funkcjonalne i niefunkcjonalne. Rozdział kończy się krótkim podsumowaniem, które ocenia, jak wdrożone funkcjonalności wpisują się w założenia projektu oraz wskazuje potencjalne kierunki dalszego rozwoju aplikacji.


\section{Architektura warstwowa}

Architektura warstwowa jest jednym z najbardziej rozpowszechnionych wzorców projektowych w inżynierii oprogramowania. Polega na podziale aplikacji na logiczne warstwy, z których każda pełni określoną funkcję. W typowej architekturze warstwowej wyróżnia się cztery kluczowe warstwy: warstwę prezentacji, logiki biznesowej, dostępu do danych oraz warstwę danych~\cite{n_tier_baeldung, n_tier_medium}. Ich ogólny schemat przedstawiono na rysunku \ref{fig:n_tier_arch}. Poszczególne elementy schematu oznaczono literami (a, b, c, d), co pozwala na ich jednoznaczną identyfikację w dalszym opisie.

\noindent Podział na warstwy przynosi wiele korzyści:
\begin{itemize}
    \item \textbf{Modularność} -- niezależność warstw ułatwia rozwój i utrzymanie systemu.
    \item \textbf{Reużywalność} -- komponenty warstw mogą być łatwo wykorzystane w innych projektach.
    \item \textbf{Skalowalność} -- warstwy można skalować oddzielnie, co zwiększa elastyczność aplikacji.
    \item \textbf{Czytelność kodu} -- podział odpowiedzialności sprawia, że kod jest bardziej przejrzysty.
    \item \textbf{Testowalność} -- warstwy mogą być testowane oddzielnie, co ułatwia identyfikację błędów.
\end{itemize}
Do wad architektury warstwowej należą:
\begin{itemize}
    \item \textbf{Potencjalny narzut} -- dodatkowe poziomy abstrakcji mogą obniżyć wydajność systemu.
    \item \textbf{Złożoność implementacji} -- koncepcja ma być bez nadmiernego zagnieżdżania warstw.
    \item \textbf{Brak elastyczności} -- w pewnych scenariuszach może być trudno dostosować architekturę do nietypowych wymagań.
\end{itemize}

Zastosowanie architektury warstwowej w systemie „Harmony Home Net” zapewnić ma jego modularność, skalowalność oraz łatwość utrzymania, spełniając wymagania zarówno użytkowników końcowych, jak i administratorów.
\begin{figure}[htb]
    \centering
    \includegraphics[scale=1.2]{rys03/diagram_architektury_warstwowej}
    \caption{Ogólny schemat architektury warstwowej}
    \label{fig:n_tier_arch}
\end{figure}

\subsection{Warstwa prezentacji (ang.\ \emph{Presentation Layer})}
Warstwa prezentacji, oznaczona literą \texttt{a)} na rysunku \ref{fig:n_tier_arch}), odpowiada za interakcję użytkownika z systemem. Na tym poziomie użytkownik wprowadza dane wejściowe, a system zwraca wyniki w formie czytelnej i zrozumiałej. Głównym zadaniem warstwy prezentacji jest renderowanie interfejsu użytkownika oraz obsługa zdarzeń takich jak kliknięcia czy przesunięcia. Odpowiada również za wstępną walidację danych wejściowych, na przykład sprawdzanie, czy wprowadzony adres e-mail ma poprawny format. Przetworzone dane są następnie przekazywane do warstwy logiki biznesowej, gdzie są dalej analizowane i przetwarzane.

W systemie ,,Harmony Home Net,, warstwę tę zrealizowano za pomocą frameworka Next.js, w~języku TypeScript. Odpowiada ona za wyświetlanie interfejsu użytkownika, w tym panelu właściela, gdzie użytkownicy mogą przeglądać zgłoszenia techniczne, dokonywać płatności oraz uczestniczyć w głosowaniach. Użycie Next.js umożliwia renderowanie po stronie serwera, co poprawia wydajność aplikacji oraz jej pozycjonowanie w wyszukiwarkach (SEO). Dzięki komponentom wielokrotnego użytku interfejs użytkownika jest spójny wizualnie i funkcjonalnie. 

\subsection{Warstwa logiki biznesowej (ang.\ \emph{Business Logic Layer})}

Warstwa logiki biznesowej, oznaczona  literą \texttt{b)} na rysunku \ref{fig:n_tier_arch}, pełni kluczową rolę w przetwarzaniu danych wejściowych i realizacji reguł biznesowych. Na tym poziomie dane są analizowane i przetwarzane zgodnie z zasadami określonymi przez specyfikę aplikacji. Główne zadania tej warstwy obejmują koordynację przepływu danych między innymi warstwami oraz obsługę wyjątków, które mogą wystąpić w wyniku błędów na wcześniejszych etapach przetwarzania.

W~systemie ,,Harmony Home Net'' warstwa ta, oparta na Spring Boot, realizuje procesy biznesowe takie jak autoryzacja użytkowników przy użyciu OAuth 2.0, zarządzanie zgłoszeniami technicznymi oraz integracja z systemami płatności. Warstwa ta komunikuje się z frontendem poprzez REST API, co zapewnia efektywne przetwarzanie żądań i odpowiedzi. Dodatkowo technologia Spring Boot umożliwia implementację skalowalnych i bezpiecznych rozwiązań, co jest kluczowe w przypadku obsługi dużej liczby użytkowników.

\subsection{Warstwa dostępu do danych (ang.\ \emph{Data Access Layer})}

Warstwa dostępu do danych, oznaczona literą \texttt{c)} na rysunku \ref{fig:n_tier_arch}, odpowiada za komunikację między logiką biznesową a fizycznym przechowywaniem danych. Jej główną funkcją jest wykonywanie operacji takich jak zapisywanie, odczytywanie, aktualizowanie i usuwanie danych w sposób zoptymalizowany i bezpieczny. Często korzysta się z bibliotek ORM, takich jak Hibernate lub JPA w Javie, które ułatwiają mapowanie danych między bazą a obiektami aplikacji.

W systemie ,,Harmony Home Net,, baza danych PostgreSQL została uruchomiona w środowisku Docker. Dzięki zastosowaniu JPA możliwe jest łatwe mapowanie danych między tabelami bazodanowymi a obiektami aplikacji w Javie. Taka implementacja umożliwia optymalizację zapytań i zapewnia wydajność operacji, co jest istotne w przypadku dużej ilości danych przechowywanych w systemie, takich jak zgłoszenia techniczne czy płatności właścieli.

\subsection{Warstwa danych (ang.\ \emph{Data Layer})}
Warstwa danych, oznaczona literą \texttt{d)} na rysunku \ref{fig:n_tier_arch}, odpowiada za trwałe przechowywanie danych aplikacji w bazach danych. Obejmuje zarządzanie strukturą danych, ich bezpieczeństwem oraz udostępnianie ich innym warstwom w sposób wydajny i zorganizowany. W systemie ,,Harmony Home Net'' wykorzystano bazę danych PostgreSQL wdrożoną w kontenerze Docker. 

Projektowanie bazy danych to jeden z kluczowych etapów tworzenia systemów informatycznych. Może odbywać się w podejściach \emph{Database First} i \emph{Code First}~\cite{DB_FIRST_VS_CODE_FIRST_1,DB_FIRST_VS_CODE_FIRST_2}. 

Podejście \emph{Code First} zakłada, że na początku w kodzie aplikacji powstanie model danych. Następnie na podstawie tego kodu zostanie wygenerowany schemat bazy danych~\cite{CODE_FIRST}. Dzięki temu podejściu możliwe są dynamiczne zmiany w~strukturze danych podczas rozwoju aplikacji. Przydaje się to w projektach, gdzie schemat bazy danych ewoluuje w odpowiedzi na zmieniające się wymagania biznesowe. Jednak w dużych projektach, w których schemat danych jest złożony i~wymaga precyzyjnej kontroli, podejście to może nie zadziałać.

Podejście \emph{Database First} polega na zaprojektowaniu schematu bazy danych, a następnie wygenerowaniu modelu aplikacji na jego podstawie. Jest to podejście bardziej tradycyjne, dające większą przewidywalność i precyzję, co jest istotne w systemach o wysokim stopniu zależności od integralności danych. Dodatkowo pozwala na pełne wykorzystanie możliwości narzędzi ORM, takich jak JPA, ponieważ bazuje na uprzednio zaprojektowanym schemacie. 

Dzięki zastosowaniu mapowania ORM dane w bazie są bezpośrednio odwzorowywane na obiekty w aplikacji, co pozwala na wygodniejsze operacje na danych. Mechanizm ORM umożliwia wykonywanie zapytań SQL w sposób abstrakcyjny i bardziej czytelny, co upraszcza implementację i zmniejsza ryzyko błędów.

\section{Struktura bazy danych}
W kontekście systemu ,,Harmony Home Net'' zdecydowano się na podejście \emph{Database First}. Zdecydowano się na to z kilku ważnych powodów.
\begin{itemize}
    \item \textbf{Centralna rola bazy danych} -- baza danych pełni kluczową funkcję w systemie, przechowując informacje o użytkownikach, lokalach, zgłoszeniach technicznych oraz płatnościach. Precyzyjne zaprojektowanie jej struktury na etapie początkowym pozwoliło na lepsze zrozumienie relacji między danymi i~ich hierarchii.
    \item \textbf{Integracja z narzędziami ORM} -- dzięki wykorzystaniu podejścia \emph{Database First}, istniejące narzędzia ORM, takie jak JPA (Java Persistence API), mogły zostać bezproblemowo dostosowane do uprzednio przygotowanego schematu bazy danych, co uprościło implementację i~zmniejszyło ryzyko błędów.
    \item \textbf{Zgodność z wymaganiami aplikacji} -- rozpoczęcie od projektowania bazy danych zapewniło uzyskanie zgodności struktury danych z wymaganiami funkcjonalnymi i niefunkcjonalnymi. Umożliwiło również identyfikację potencjalnych problemów na wczesnym etapie prac.
    \item \textbf{Bezpieczeństwo i integralność danych} -- projektując bazę danych jako pierwszą można było od razu uwzględnić mechanizmy zabezpieczeń, takie jak klucze główne, obce oraz indeksy. Zminimalizowało to ryzyko wystąpienia niespójności danych w trakcie działania systemu.
\end{itemize}

\subsection{Opis struktury bazy danych}

Strukturę bazy danych w systemie „Harmony Home Net” zaprojektowano z uwzględnieniem wymagań funkcjonalnych i niefunkcjonalnych aplikacji. Schemat bazy danych podzielono na warstwę konceptualną (rysunek \ref{fig:ebok_db_concept}) oraz fizyczną (rysunek \ref{fig:ebok_db_physical}), co umożliwiło dokładne odwzorowanie relacji pomiędzy danymi oraz optymalizację ich przechowywania.
\begin{figure}[ht]
    \centering
    \includegraphics[width=.9\linewidth]{rys03/ebok_db_concept}
    \caption{Schemat konceptualny bazy danych systemu}
    \label{fig:ebok_db_concept}
\end{figure}
\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{rys03/ebok_db_physical} % TO DO: da się jeszcze zacieśnić tabele (przesunąć lekko do lewej to po prawej stronie licząc od połowy)
    \caption{Schemat fizyczny bazy danych systemu}
    \label{fig:ebok_db_physical}
\end{figure}

\subsubsection{Opis tabel}
Poniżej szczegółowo opisano wszystkie tabele w bazie danych:

\begin{itemize}
    \item \textbf{Tabela \texttt{Users}:}
    Przechowuje dane o użytkownikach, takie jak:
    \begin{itemize}
        \item \texttt{FirstName} i \texttt{LastName} -- imię i nazwisko użytkownika,
        \item \texttt{Email} -- unikalny adres e-mail,
        \item \texttt{Password} -- zaszyfrowane hasło,
        \item \texttt{Role} -- rola w systemie (np. właściciel, pracownik, administrator),
        \item \texttt{CreateAt} i \texttt{UpdateAt} -- daty utworzenia i ostatniej modyfikacji rekordu.
    \end{itemize}
    Klucz główny \texttt{UUID} jest wykorzystywany jako klucz obcy w wielu innych tabelach, zapewniając spójność relacji.

    \item \textbf{Tabela \texttt{Apartments}:}
    Zawiera szczegółowe dane o lokalach:
    \begin{itemize}
        \item \texttt{ApartmentSignature} -- unikalny identyfikator lokalu,
        \item \texttt{Address}, \texttt{City} i \texttt{ZipCode} -- adres lokalu,
        \item \texttt{ApartmentArea} -- powierzchnia,
        \item \texttt{ApartmentPercentValue} -- udział procentowy w nieruchomości wspólnej.
    \end{itemize}
    Powiązana z użytkownikami poprzez klucz obcy \texttt{UsersUUID}.
    
    \item \textbf{Tabela \texttt{Payments}:}
    Rejestruje dane o płatnościach:
    \begin{itemize}
        \item \texttt{Description}, \texttt{PaymentStatus}, \texttt{PaymentDate}, \texttt{PaymentAmount},
        \item \texttt{ReadyToPay} -- znacznik stanu płatności.
    \end{itemize}

    \item \textbf{Tabela \texttt{PaymentComponent}:}
    Szczegółowo opisuje składniki płatności, co pozwala na większą elastyczność w obliczaniu należności. Przechowuje informacje takie jak:
    \begin{itemize}
        \item \texttt{ComponentType} -- typ składnika płatności (np. czynsz, media, fundusz remontowy),
        \item \texttt{UnitPrice} i \texttt{ComponentAmount} -- cena jednostkowa i łączna kwota dla składnika,
        \item \texttt{SpecialMultipliers} -- specjalne mnożniki stosowane w obliczeniach (np. liczba osób, powierzchnia lokalu),
        \item \texttt{Unit} -- jednostka składnika (np. m\textsuperscript{2}, sztuki).
    \end{itemize}
    Tabela jest powiązana z tabelą \texttt{Payments} poprzez klucz obcy \texttt{PaymentsUUID}.

    \item \textbf{Tabela \texttt{ProblemReports}:}
    Zawiera zgłoszenia techniczne dotyczące lokali:
    \begin{itemize}
        \item \texttt{Status}, \texttt{Category}, \texttt{Note} -- szczegóły zgłoszenia,
        \item Klucze obce \texttt{UsersUUID} i \texttt{ApartmentsUUID}.
    \end{itemize}

    \item \textbf{Tabele \texttt{Polls} i \texttt{Votes}:} 
		Obsługują głosowania: tabela \texttt{Polls} zawiera dane głosowań, a \texttt{Votes} przechowuje głosy użytkowników. Wprowadzono ograniczenie unikalności głosów w relacji \texttt{pollId} oraz \texttt{apartmentSignature}.

    \item \textbf{Tabela \texttt{Documents} i \texttt{UserDocumentConnection}:}
    \texttt{UserDocumentConnection} pełni rolę łącznika w relacji wiele do wielu między \texttt{Users} a \texttt{Documents}. Tabela \texttt{Documents} przechowuje informacje o plikach, takie jak nazwa, typ, treść (\texttt{UploadData}) oraz data dodania.
    
    \item \textbf{Tabela \texttt{Announcements} i \texttt{AnnouncementApartment}:}
    \texttt{Announcements} przechowuje ogłoszenia, a \texttt{AnnouncementApartment} pełni rolę tabeli łącznikowej w relacji wiele do wielu między \texttt{Announcements} a \texttt{Apartments}.

    \item \textbf{Tabela \texttt{NotificationTypes}:}
    Przechowuje różne typy powiadomień i ich relacje z użytkownikami. Zdefiniowano ograniczenie unikalności, które uniemożliwia przypisanie tego samego typu powiadomienia temu samemu użytkownikowi wielokrotnie.

    \item \textbf{Tabela \texttt{PossessionHistory}:}
    Rejestruje historię przypisania użytkowników do lokali:
    \begin{itemize}
        \item \texttt{StartDate} i \texttt{EndDate} -- okres użytkowania lokalu,
        \item Klucze obce \texttt{ApartmentsUUID} i \texttt{UsersUUID}.
        \item Zastosowano ograniczenie unikalności relacji między \texttt{userId} a \texttt{apartmentId}.
    \end{itemize}
\end{itemize}

\subsubsection{Podział tabel na pakiety}

W implementacji kodu wszystkie tabele zostały podzielone na dwa logiczne pakiety:
\begin{itemize}
    \item \textbf{Pakiet \texttt{sideTables}:} Obejmuje tabele pomocnicze, które pełnią rolę łączników w relacjach wiele do wielu. Należą do niego:
    \begin{itemize}
        \item \texttt{UserDocumentConnection},
        \item \texttt{PossessionHistory},
        \item \texttt{AnnouncementApartment}.
    \end{itemize}

    \item \textbf{Pakiet \texttt{mainTables}:} Obejmuje główne tabele przechowujące kluczowe dane systemu:
		\begin{multicols}{2}\setlength\topskip{0pt}
    \begin{itemize}
        \item \texttt{Users},
        \item \texttt{Apartments},
        \item \texttt{Payments},
        \item \texttt{PaymentComponent},
        \item \texttt{ProblemReports},
        \item \texttt{Polls},
        \item \texttt{Votes},
        \item \texttt{Documents},
        \item \texttt{Announcements},
        \item \texttt{NotificationTypes}.
    \end{itemize}
		\end{multicols}
\end{itemize}

Podział tabel na dwa pakiety zapewnia przejrzystość struktury kodu, łatwość zarządzania relacjami między encjami oraz ułatwia przyszłą rozbudowę systemu.


\subsection{Relacje i integralność danych}

Relacje między tabelami zostały szczegółowo odwzorowane za pomocą kluczy głównych i obcych, co umożliwia utrzymanie integralności danych oraz łatwe zarządzanie połączeniami między różnymi elementami bazy. Na przykład, tabela \texttt{Problem\_reports} zawiera klucze obce do tabel \texttt{Users} i \texttt{Apartments}, co pozwala na przypisanie zgłoszeń technicznych zarówno do konkretnego użytkownika, jak i lokalu. Analogicznie, tabela \texttt{Payments} jest powiązana z tabelą \texttt{Apartments}, co zapewnia pełną kontrolę nad płatnościami przypisanymi do danych lokali.

\subsection{Mechanizmy optymalizacyjne}

W celu poprawy wydajności bazy danych zastosowano następujące mechanizmy:
\begin{itemize}
    \item \textbf{Indeksy} -- kluczowe kolumny, takie jak \texttt{UUID}, zostały zaindeksowane w celu przyspieszenia operacji wyszukiwania i sortowania.
    \item \textbf{Mapowanie ORM} -- baza danych została zintegrowana z aplikacją za pomocą narzędzia JPA (Java Persistence API), co umożliwia bezpośrednie mapowanie tabel na obiekty w kodzie aplikacji. Dzięki temu operacje CRUD (Create, Read, Update, Delete) mogą być realizowane w sposób wygodny i abstrakcyjny, bez konieczności pisania zapytań SQL.
    \item \textbf{Konteneryzacja} -- PostgreSQL działa w środowisku Docker, co zapewnia łatwość zarządzania i możliwość skalowania systemu w zależności od obciążenia.
		\item \textbf{Ograniczenia unikalności (ang. Unique Constraint)} -- w tabelach takich jak \texttt{Votes}, \texttt{PossessionHistory}, \texttt{NotificationTypes}, oraz \texttt{AnnouncementApartment} zastosowano ograniczenia unikalności (\texttt{UniqueConstraints}), co zapobiega wprowadzaniu niepożądanych duplikatów w relacjach wiele do wielu.
\end{itemize}

\subsection{Podsumowanie}

Struktura bazy danych systemu \textbf{Harmony Home Net} została zaprojektowana w sposób umożliwiający jej skalowalność, wydajność oraz łatwość integracji z innymi komponentami aplikacji. Podejście \emph{Database First} okazało się optymalnym wyborem, zapewniając precyzyjne odwzorowanie wymagań biznesowych i technicznych systemu. Schematy konceptualny (rysunek \ref{fig:ebok_db_concept}) i fizyczny (rysunek \ref{fig:ebok_db_physical}) ilustrują relacje pomiędzy tabelami, które stanowią podstawę spójnego i efektywnego zarządzania danymi.

\section{Bezpieczeństwo, uwierzytelnianie i autoryzacja w~aplikacji}
% TO DO: pojawiło się wodolejstwo. Opisał Pan dość dokładnie zawartość podrozdziałów, by potem tę zawartość dokładnie przedstawić. Efekt - pewien galimatias.
%        trochę poskracałem i uporzatkowałem treść, ale jeszcze nie jestem zadowolony z efektu.
Aby zapewnić ochronę danych użytkowników oraz bezpieczny dostęp do zasobów w implementacji systemu „Harmony Home Net” wdrożono różne mechanizmy bezpieczeństwa. Zastosowano przy tym Spring Security, wykorzystując obsługą tokenów JWT oraz \emph{OAuth 2.0 Resource Server} do uwierzytelniania i autoryzacji. 

Poniżej wyjaśniono rolę \emph{OAuth 2.0 Resource Server} w weryfikacji tokenów dostępu generowanych w ramach sesji użytkownika. Mechanizm ten umożliwia bezpieczne zarządzanie dostępem do zasobów oraz bezstanowe uwierzytelnianie użytkowników, eliminując konieczność utrzymywania sesji po stronie serwera.

Następnie zajęto się filtrami bezpieczeństwa (\emph{SecurityFilterChain}), zarządzaniem sesjami w trybie bezstanowym oraz zabezpieczeniem API za pomocą tokenów JWT i \emph{OAuth 2.0 Resource Server}. W tej części przedstawiono również znaczenie \texttt{JwtAuthenticationConverter} i jego rolę w integracji z mechanizmami Spring Security. Następnie zwrócono uwagę na proces logowania z wykorzystaniem nazw użytkowników, haseł oraz generowania tokenów JWT. Proces uwierzytelniania użytkowników opisano w oparciu o klasę \texttt{UserInfoManagerConfig}, która integruje bazę danych z mechanizmami uwierzytelniania w Spring Security.

W osobnym podrozdziale opisano zarządzanie tokenami JWT i autoryzacji użytkowników. W procesie tym obsłużono schemat związany z uwierzytelnianiem użytkowników przy użyciu \emph{OAuth 2.0 Resource Server}. Zaimplementowane mechanizmy pozwalają na sprawdzanie poprawności i wykrywania wygasłych lub nieautoryzowanych tokenów. Kluczową rolę pełni w tym klasa \texttt{JwtAccessTokenFilter}, która weryfikuje tokeny w żądaniach HTTP.

Przedstawiono też implementacją usługi \texttt{TokenBlacklistService}, która pozwala na unieważnianie tokenów w momencie wylogowania użytkownika. Dzięki temu użytkownicy mogą zostać natychmiast wylogowani, a sesje mogą być anulowane w przypadku wykrycia naruszeń bezpieczeństwa. Usługa obejmuje również harmonogram automatycznego usuwania wygasłych tokenów z czarnej listy, co zwiększa wydajność systemu.

Podrozdział kończy omówienie mechanizmy resetowania hasła. Bazuje on na konfiguracja specjalnego łańcucha filtrów bezpieczeństwa, który umożliwia różnicowanie poziomów dostępu na podstawie ścieżek. Mechanizm ten obsługuje żądania związane z resetowaniem hasła, przy zachowaniu odpowiedniego poziomu bezpieczeństwa dla publicznych punktów końcowych.


\subsection{Konfiguracja łańcucha filtrów bezpieczeństwa}
Łańcuch filtrów bezpieczeństwa (\emph{Security Filter Chain}) odgrywa kluczową rolę w zapewnieniu ochrony aplikacji. W systemie „Harmony Home Net” został on skonfigurowany przy użyciu klasy \texttt{SecurityConfig}, która definiuje różne ścieżki żądań oraz odpowiadające im mechanizmy uwierzytelniania i autoryzacji. Każda ścieżka obsługiwana jest przez dedykowany łańcuch filtrów, co umożliwia elastyczne zarządzanie poziomem bezpieczeństwa.

W konfiguracji wykorzystano mechanizm \texttt{JwtAuthenticationConverter}, który umożliwia niestandardowe przekształcanie tokenów JWT na obiekty \texttt{Authentication}, dodając autoryzacje na podstawie zawartości tokenu. Dzięki temu aplikacja może elastycznie zarządzać dostępem użytkowników na podstawie przypisanych im ról lub innych atrybutów zawartych w tokenie JWT.

Kluczowym elementem konfiguracji jest również zastosowanie adnotacji \texttt{@Order}. Każdy łańcuch filtrów posiada określoną kolejność, która decyduje o tym, w jakiej sekwencji będą przetwarzane żądania. Dzięki temu można precyzyjnie kontrolować, które mechanizmy mają priorytet w przetwarzaniu poszczególnych ścieżek. Niewłaściwe ustawienie kolejności mogłoby spowodować nieprawidłowe działanie zabezpieczeń.

W systemie zaimplementowano cztery główne łańcuchy filtrów:
\begin{itemize}
    \item \textbf{Łańcuch obsługi resetowania hasła} -- scieżki \texttt{/auth/forgot-password} i \texttt{/auth/reset-password} są publicznie dostępne bez konieczności uwierzytelniania (\texttt{@Order(1)}).
    \item \textbf{Łańcuch logowania} -- obsługuje ścieżkę \texttt{/auth/login}, zapewniając uwierzytelnianie użytkownika przy użyciu nazw użytkowników i haseł (\texttt{@Order(2)}).
    \item \textbf{Łańcuch API} -- chroni wszystkie ścieżki API zaczynające się od \texttt{/api/v1/}, wymagając tokenu JWT do autoryzacji (\texttt{@Order(3)}).
    \item \textbf{Łańcuch wylogowania} -- obsługuje ścieżkę \texttt{/logout}, umożliwiając wylogowanie użytkownika i unieważnienie tokenu JWT (\texttt{@Order(4)}).
\end{itemize}

Każdy z łańcuchów został skonfigurowany jako komponent Spring Bean, dzięki czemu można elastycznie dostosowywać ustawienia w zależności od potrzeb. Poniżej przedstawiono pełny kod konfiguracji:

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Pełna konfiguracja łańcucha filtrów bezpieczeństwa]
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
@RequiredArgsConstructor
@Import(JwtConfig.class)
public class SecurityConfig {

    private final UserInfoManagerConfig userInfoManagerConfig;
    private final RSAKeyRecord rsaKeyRecord;
    private final JwtTokenUtils jwtTokenUtils;
    private final TokenBlacklistService tokenBlacklistService;

    @Order(1)
    @Bean
    public SecurityFilterChain forgotPasswordSecurityFilterChain(HttpSecurity httpSecurity) throws Exception {
        return httpSecurity
					.securityMatcher(new OrRequestMatcher(
									new AntPathRequestMatcher("/auth/forgot-password"),
									new AntPathRequestMatcher("/auth/reset-password")
					))
					.csrf(AbstractHttpConfigurer::disable)
					.authorizeHttpRequests(auth -> auth.anyRequest().permitAll())
					.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
					.cors(withDefaults())
					.build();
    }

    @Order(2)
    @Bean
    public SecurityFilterChain loginSecurityFilterChain(HttpSecurity http) throws Exception {
        return http
					.securityMatcher(new AntPathRequestMatcher("/auth/login"))
					.csrf(AbstractHttpConfigurer::disable)
					.authorizeHttpRequests(auth -> auth.anyRequest().authenticated())
					.userDetailsService(userInfoManagerConfig)
					.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
					.httpBasic(withDefaults())
					.cors(withDefaults())
					.build();
    }

    @Order(3)
    @Bean
    public SecurityFilterChain apiSecurityFilterChain(HttpSecurity http) throws Exception {
        return http
					.securityMatcher(new AntPathRequestMatcher("/api/v1/**"))
					.csrf(AbstractHttpConfigurer::disable)
					.authorizeHttpRequests(auth -> auth.anyRequest().authenticated())
					.oauth2ResourceServer(oauth2 -> oauth2
									.jwt(jwt -> jwt.jwtAuthenticationConverter(jwtAuthenticationConverter()))
					)
					.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
					.addFilterBefore(new JwtAccessTokenFilter(rsaKeyRecord, jwtTokenUtils, tokenBlacklistService), UsernamePasswordAuthenticationFilter.class)
					.cors(withDefaults())
					.build();
    }

    @Order(4)
    @Bean
    public SecurityFilterChain logoutSecurityFilterChain(HttpSecurity httpSecurity) throws Exception {
        return httpSecurity
						.securityMatcher(new AntPathRequestMatcher("/logout"))
						.csrf(AbstractHttpConfigurer::disable)
						.authorizeHttpRequests(auth -> auth.anyRequest().authenticated())
						.logout(logout -> logout
										.logoutUrl("/logout")
										.logoutSuccessHandler((request, response, authentication) -> {
												String token = request.getHeader("Authorization").replace("Bearer ", "");
												tokenBlacklistService.blacklistToken(token);
												SecurityContextHolder.clearContext();
										})
						)
						.cors(withDefaults())
						.build();
    }

    @Bean
    public JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtAuthenticationConverter converter = new JwtAuthenticationConverter();
        converter.setJwtGrantedAuthoritiesConverter(jwt -> {
            List<GrantedAuthority> authorities = new ArrayList<>();
            String role = jwt.getClaimAsString("role");
            if (role != null) {
                authorities.add(new SimpleGrantedAuthority(role));
            }
            return authorities;
        });
        return converter;
    }
}
\end{lstlisting}

%---
\noindent
Dzięki tej konfiguracji system:
\begin{itemize}
    \item Rozdziela odpowiedzialność za różne ścieżki żądań, pozwalając na precyzyjne zarządzanie dostępem.
    \item Wykorzystuje \texttt{JwtAuthenticationConverter} do niestandardowego zarządzania autoryzacją na podstawie zawartości tokenu JWT.
    \item Umożliwia bezstanowe zarządzanie sesjami za pomocą tokenów JWT.
    \item Zachowuje odpowiednią kolejność przetwarzania żądań dzięki zastosowaniu adnotacji \texttt{@Order}.
\end{itemize}

\subsection{Proces logowania}

Mechanizm logowania w systemie „Harmony Home Net” został zaprojektowany w oparciu o Spring Security i tokeny JWT. Poniżej przedstawiono szczegółowy opis procesu logowania, krok po kroku, na podstawie schematu zaprezentowanego na rysunku \ref{fig:ebok_db_concept}.

\begin{figure}[ht]
    \centering
    \includegraphics[width=.9\linewidth]{rys03/proces_logowania}
    \caption{Schemat działania procesu logowania w systemie~\cite{JWToauth}}
    \label{fig:ebok_db_concept}
\end{figure}

Proces logowania składa się z następujących kroków, oznaczonych literami \textbf{a}–\textbf{e} na schemacie:

\begin{enumerate}
    \item \textbf{Przesłanie danych logowania \texttt{a)}} -- Użytkownik wysyła żądanie HTTP \texttt{POST} na endpoint \texttt{/auth/login}, dostarczając swoje dane logowania, takie jak nazwa użytkownika i hasło. 
		
    \item \textbf{Uwierzytelnienie użytkownika przez \texttt{AuthenticationManager} \texttt{b)}} -- \texttt{AuthenticationManager} to kluczowy komponent Spring Security, który weryfikuje dane logowania. W pierwszym kroku proces uwierzytelniania odbywa się za pomocą dostarczonej nazwy użytkownika i hasła.

    \item \textbf{Sprawdzenie danych w repozytorium użytkowników \texttt{c)}} -- \texttt{AuthenticationManager} deleguje żądanie do repozytorium użytkowników (\texttt{UserRepository}), które weryfikuje, czy użytkownik o podanym loginie istnieje w systemie. W tym celu wykorzystywana jest klasa \texttt{UserInfoManagerConfig}, która implementuje interfejs \texttt{UserDetailsService}. Jeśli użytkownik nie zostanie znaleziony lub dane logowania są niepoprawne, proces logowania kończy się niepowodzeniem i zwracany jest status \texttt{HTTP 403}.

    \item \textbf{Generowanie tokenu JWT \texttt{d)}} -- Jeśli dane logowania są poprawne, na podstawie informacji o użytkowniku generowany jest token JWT za pomocą usługi \texttt{JwtService}. Token zawiera zaszyfrowane informacje, takie jak identyfikator użytkownika, rola w systemie oraz data wygaśnięcia. Klucze RSA zapewniają bezpieczeństwo tokenu.

    \item \textbf{Zwrócenie tokenu JWT w odpowiedzi \texttt{e)}} -- Token JWT jest przesyłany do użytkownika w odpowiedzi HTTP \texttt{200}. Użytkownik przechowuje token lokalnie (np. w pamięci przeglądarki lub w \emph{sessionStorage}), aby używać go do autoryzacji kolejnych żądań do API. Token posiada czas ważności 10 minut, co zapewnia odpowiedni balans pomiędzy bezpieczeństwem a wygodą użytkownika:
\begin{itemize}
    \item Krótki czas ważności minimalizuje ryzyko wykorzystania tokenu przez osoby nieuprawnione w przypadku jego przechwycenia lub zgubienia.
    \item Jednocześnie, 10 minut jest wystarczające dla typowych operacji użytkownika, takich jak przeglądanie aplikacji i wykonywanie kolejnych żądań API bez konieczności częstego odświeżania tokenu.
\end{itemize}
 
\end{enumerate}

W szczególności klasa \texttt{UserInfoManagerConfig}, wykorzystywana w kroku \texttt{c)}, odpowiada za weryfikację istnienia użytkownika w bazie danych oraz dostarczenie szczegółów użytkownika wymaganych przez mechanizm uwierzytelniania. Kod klasy przedstawiono poniżej:

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Klasa \texttt{UserInfoManagerConfig} odpowiedzialna za zarządzanie użytkownikami]
package bwp.hhn.backend.harmonyhomenetlogic.configuration.security;

import bwp.hhn.backend.harmonyhomenetlogic.repository.mainTables.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class UserInfoManagerConfig implements UserDetailsService {

    private final UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        return userRepository.findByEmail(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));
    }
}
\end{lstlisting}

Kluczowe funkcje tej klasy:
\begin{itemize}
    \item \textbf{Implementacja metody \texttt{loadUserByUsername}:} Weryfikuje istnienie użytkownika w bazie danych na podstawie adresu e-mail.
    \item \textbf{Obsługa wyjątków:} W przypadku, gdy użytkownik nie zostanie znaleziony, rzucany jest wyjątek \texttt{UsernameNotFoundException}, który kończy proces logowania.
    \item \textbf{Repozytorium \texttt{UserRepository}:} Umożliwia dostęp do bazy danych w celu wyszukiwania użytkowników.
\end{itemize}

Mechanizm logowania zapewnia bezpieczną i bezstanową autoryzację użytkowników, minimalizując ryzyko naruszenia danych i nieuprawnionego dostępu.

\subsection{Zarządzanie tokenami JWT i autoryzacja użytkowników}

Zarządzanie tokenami JWT w systemie „Harmony Home Net” opiera się na zaawansowanych mechanizmach walidacji i autoryzacji, integrując je z frameworkiem Spring Security. Schemat ilustrujący proces dostępu do zasobów systemu pokazano na rysunku \ref{fig:resource_access_flow}.
\begin{figure}[ht]
    \centering
    \includegraphics[width=.9\linewidth]{rys03/Diagram_dotępu_do_zasobów_systemu}  % TO DO: proszę poprawić skośne strzałki na poziome, poprawić bałagan przy HTTP:403 - strzałki nie muszą przecinać się)
    \caption{Diagram zarządzania tokenami JWT i autoryzacji użytkowników~\cite{JWToauth}}
    \label{fig:resource_access_flow}
\end{figure}

Proces ten składa się z następujących kroków:
\begin{enumerate}
    \item[\texttt{a)}] Przesłanie żądania przez użytkownika -- użytkownik wysyła żądanie HTTP do usługi API z dołączonym tokenem JWT w nagłówku \texttt{Authorization}.
    
    \item[\texttt{b)}] Przechwycenie żądania przez \texttt{JwtAccessTokenFilter} -- niestandardowy filtr \texttt{JwtAccessTokenFilter}, zintegrowany z \texttt{SecurityFilterChain}, przechwytuje żądanie i analizuje token JWT. Jeśli token jest nieobecny lub niepoprawny, zwracana jest odpowiedź z kodem HTTP \texttt{403}.
    
    \item[\texttt{c)}] Ekstrakcja danych z tokenu JWT przez \texttt{Jwt Service / OAuth 2.0 Resource Server} -- w przypadku obecności tokenu JWT, usługa \texttt{Jwt Service}, korzystająca z mechanizmu \emph{OAuth 2.0 Resource Server}, jest wywoływana w celu ekstrakcji adresu e-mail użytkownika (\texttt{userEmail}). Jeśli dane użytkownika nie mogą zostać odczytane lub token jest nieprawidłowy, zwracany jest status HTTP \texttt{403}.

    \item[\texttt{d)}] Sprawdzenie użytkownika w bazie danych -- Wyodrębniony adres e-mail użytkownika jest wykorzystywany do zapytania w bazie danych za pomocą \texttt{UserDetailsService}. Jeśli użytkownik nie istnieje w bazie, zwracana jest odpowiedź z kodem HTTP \texttt{403}.
    
    \item[\texttt{e)}] Walidacja tokenu JWT -- token JWT jest weryfikowany pod kątem poprawności oraz daty ważności. Jeśli token wygasł, zwracana jest odpowiedź HTTP \texttt{403}.
    
    \item[\texttt{f)}] Utworzenie obiektu \texttt{UsernamePasswordAuthenticationToken} -- jeśli token JWT jest ważny, informacje o użytkowniku są przetwarzane w obiekt \texttt{UsernamePasswordAuthenticationToken}, który następnie jest przechowywany w \texttt{SecurityContextHolder}.
    
    \item[\texttt{g)}] Autoryzacja przez Spring Security -- mechanizm autoryzacji Spring Security jest automatycznie wywoływany, aby sprawdzić, czy użytkownik ma odpowiednie uprawnienia do dostępu do zasobów.
    
    \item[\texttt{h)}] Przekazanie żądania do kontrolera -- po pomyślnym uwierzytelnieniu i autoryzacji żądanie jest kierowane do odpowiedniego kontrolera, który obsługuje dalsze przetwarzanie.
    
    \item[\texttt{i)}] Zwrócenie odpowiedzi -- po przetworzeniu żądania kontroler zwraca odpowiedź JSON z kodem HTTP \texttt{200}.
\end{enumerate}

Kluczowym elementem procesu zarządzania tokenami JWT jest klasa \texttt{JwtAccessTokenFilter}, której zadaniem jest przechwytywanie i weryfikacja tokenów JWT w żądaniach HTTP. Kod tej klasy przedstawiono poniżej:

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Kod niestandardowego filtra \texttt{JwtAccessTokenFilter}]
@RequiredArgsConstructor
public class JwtAccessTokenFilter extends OncePerRequestFilter {

    private final RSAKeyRecord rsaKeyRecord;
    private final JwtTokenUtils jwtTokenUtils;
    private final TokenBlacklistService tokenBlacklistService;

    @Override
    protected void doFilterInternal(@NonNull HttpServletRequest request, 
                                    @NonNull HttpServletResponse response, 
                                    @NonNull FilterChain filterChain) 
            throws ServletException, IOException {

        final String authHeader = request.getHeader(HttpHeaders.AUTHORIZATION);

        if (authHeader == null || !authHeader.startsWith(TokenType.Bearer.name())) {
            filterChain.doFilter(request, response);
            return;
        }

        final String token = authHeader.substring(7);

        if (tokenBlacklistService.isTokenBlacklisted(token)) {
            response.setStatus(HttpStatus.UNAUTHORIZED.value());
            response.getWriter().write("Token is blacklisted");
            return;
        }

        JwtDecoder jwtDecoder = NimbusJwtDecoder.withPublicKey(rsaKeyRecord.publicKey()).build();
        Jwt jwtToken = jwtDecoder.decode(token);

        String userName = jwtTokenUtils.getUserName(jwtToken);

        if (userName != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            UserDetails userDetails = jwtTokenUtils.userDetails(userName);

            if (jwtTokenUtils.isTokenValid(jwtToken, userDetails)) {
                UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                        userDetails, null, userDetails.getAuthorities());
                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
        }
        filterChain.doFilter(request, response);
    }
}
\end{lstlisting}

\noindent Opis działania klasy:
\begin{itemize}
    \item Klasa \texttt{JwtAccessTokenFilter} dziedziczy po \texttt{OncePerRequestFilter}, dzięki czemu jest wywoływana raz dla każdego żądania.
    \item Weryfikacja nagłówka \texttt{Authorization} zapewnia, że token JWT jest obecny i poprawny.
    \item Tokeny znajdujące się na czarnej liście są odrzucane z kodem HTTP \texttt{401}.
    \item Token JWT jest dekodowany za pomocą klucza publicznego RSA, a dane użytkownika są odczytywane i weryfikowane.
    \item Po pomyślnej weryfikacji dane użytkownika są zapisywane w \texttt{SecurityContextHolder}, umożliwiając dalszy proces autoryzacji.
\end{itemize}


Klasa \texttt{JwtConfig} zapewnia konfigurację mechanizmów dekodowania i kodowania tokenów JWT przy użyciu kluczy RSA. Jej kod przedstawiono poniżej.
\begin{lstlisting}[language=Java, style=JavaStyle, caption=Klasa \texttt{JwtConfig}]
@Configuration
public class JwtConfig {

    private final RSAKeyRecord rsaKeyRecord;

    public JwtConfig(RSAKeyRecord rsaKeyRecord) {
        this.rsaKeyRecord = rsaKeyRecord;
    }

    @Bean
    public JwtDecoder jwtDecoder() {
        return NimbusJwtDecoder.withPublicKey(rsaKeyRecord.publicKey()).build();
    }

    @Bean
    public JwtEncoder jwtEncoder() {
        JWK jwk = new RSAKey.Builder(rsaKeyRecord.publicKey())
                           .privateKey(rsaKeyRecord.privateKey())
                           .build();
        JWKSource<SecurityContext> jwkSource = new ImmutableJWKSet<>(new JWKSet(jwk));
        return new NimbusJwtEncoder(jwkSource);
    }
}
\end{lstlisting}

Klasa \texttt{JwtTokenUtils} odpowiada za operacje związane z tokenami JWT, takie jak ekstrakcja danych, weryfikacja poprawności oraz walidacja zgodności z danymi użytkownika. Jej kod przedstawiono poniżej.

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Klasa \texttt{JwtTokenUtils}]
@Component
@RequiredArgsConstructor
public class JwtTokenUtils {

    private final UserRepository userRepository;

    public String getUserName(Jwt jwtToken) {
        return jwtToken.getSubject();
    }

    public boolean isTokenValid(Jwt jwtToken, UserDetails userDetails) {
        final String userName = getUserName(jwtToken);
        boolean isTokenExpired = jwtToken.getExpiresAt().isBefore(Instant.now());
        return !isTokenExpired && userName.equals(userDetails.getUsername());
    }

    public UserDetails userDetails(String email) {
        return userRepository.findByEmail(email)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));
    }
}
\end{lstlisting}

\begin{itemize}
    \item \texttt{JwtAccessTokenFilter} przechwytuje żądania HTTP, weryfikuje tokeny JWT i zapisuje dane użytkownika w kontekście bezpieczeństwa.
    \item \texttt{JwtTokenUtils} obsługuje logikę ekstrakcji i walidacji danych z tokenu.
    \item \texttt{JwtConfig} dostarcza konfigurację mechanizmów kodowania i dekodowania tokenów JWT z użyciem kluczy RSA.
\end{itemize}


\subsection{Zarządzanie czarną listą tokenów}

Mechanizm zarządzania czarną listą tokenów w systemie „Harmony Home Net” umożliwia unieważnienie tokenów JWT. Jest to szczególnie istotne w procesie wylogowania użytkownika. Dzięki temu można natychmiast zakończyć sesję użytkownika i uniemożliwić dostęp do zasobów chronionych systemu przy użyciu starego tokenu.

\noindent \textbf{Proces wylogowania i dodawania tokenu do czarnej listy}\newline
Podczas wylogowania system korzysta z dedykowanego łańcucha filtrów \texttt{logoutSecurityFilterChain}, zdefiniowanego w klasie \texttt{SecurityConfig}. Fragment konfiguracji przedstawiono poniżej.

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Konfiguracja łańcucha wylogowania]
@Bean
@Order(4)
public SecurityFilterChain logoutSecurityFilterChain(HttpSecurity httpSecurity) throws Exception {
    return httpSecurity
            .securityMatcher(new AntPathRequestMatcher("/logout"))
            .csrf(AbstractHttpConfigurer::disable)
            .authorizeHttpRequests(auth -> auth.anyRequest().authenticated())
            .oauth2ResourceServer(oauth2 -> oauth2.jwt(withDefaults()))
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .logout(logout -> logout
                    .logoutUrl("/logout")
                    .logoutSuccessHandler((request, response, authentication) -> {
                        String token = request.getHeader("Authorization").replace("Bearer ", "");
                        tokenBlacklistService.blacklistToken(token);
                        SecurityContextHolder.clearContext();
                    })
            )
            .cors(withDefaults())
            .build();
}
\end{lstlisting}

Podczas wylogowania użytkownik wysyła żądanie HTTP na ścieżkę \texttt{/logout}. Mechanizm \texttt{logoutSuccessHandler} wykonuje następujące kroki:
\begin{itemize}
    \item Ekstrakcja tokenu JWT z nagłówka \texttt{Authorization}.
    \item Dodanie tokenu do czarnej listy za pomocą usługi \texttt{TokenBlacklistService}.
    \item Wyczyszczenie kontekstu bezpieczeństwa (\texttt{SecurityContextHolder}) w celu unieważnienia sesji użytkownika.
\end{itemize}

\noindent \textbf{Zarządzanie czarną listą tokenów}\newline
Klasa \texttt{TokenBlacklistService} odpowiada za przechowywanie tokenów w czarnej liście oraz ich usuwanie po wygaśnięciu. Kod klasy przedstawiono poniżej.

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Klasa \texttt{TokenBlacklistService}]
@Service
@RequiredArgsConstructor
public class TokenBlacklistService {
    private final Set<String> blacklistedTokens = new HashSet<>();
    private final JwtDecoder jwtDecoder;

    public void blacklistToken(String token) {
        blacklistedTokens.add(token);
    }

    public boolean isTokenBlacklisted(String token) {
        return blacklistedTokens.contains(token);
    }

    @Scheduled(cron = "0 */15 * * * *") // Every 15 minutes
    @Async
    public void clearExpiredTokens() {
        blacklistedTokens.removeIf(this::isTokenExpired);
    }

    private boolean isTokenExpired(String token) {
        return Date.from(
                Objects.requireNonNull(
                        jwtDecoder.decode(token).getExpiresAt()
                )
        ).before(new Date());
    }
}
\end{lstlisting}

\noindent Znaczenie metody tej klasy jest następujące:
\begin{itemize}
    \item \texttt{blacklistToken} -- dodaje token JWT do czarnej listy w momencie wylogowania.
    \item \texttt{isTokenBlacklisted} -- sprawdza, czy dany token znajduje się na czarnej liście.
    \item \texttt{clearExpiredTokens} -- usuwa z czarnej listy tokeny, które wygasły, aby ograniczyć zużycie pamięci.
\end{itemize}

\noindent \textbf{Harmonogram czyszczenia czarnej listy}\newline
Usługa \texttt{TokenBlacklistService} korzysta z metody \texttt{@Scheduled}, która co 15 minut sprawdza i usuwa tokeny wygasłe. Jest to realizowane asynchronicznie, dzięki czemu proces ten nie wpływa na wydajność aplikacji.

Dzięki istnieniu czarnych list system skutecznie zapobiega nieautoryzowanemu dostępowi do zasobów po wylogowaniu użytkownika lub wykryciu naruszenia bezpieczeństwa.

\subsection{Mechanizmy resetowania hasła}

Mechanizm resetowania hasła zaprojektowano z uwzględnieniem podstawowych wymagań bezpieczeństwa. Proces został uproszczony w stosunku do tego, jak wyglądałby w pełnoprawnej produkcyjnej aplikacji. W profesjonalnych wdrożeniach resetowanie hasła zwykle obejmuje podział na osobne endpointy oraz wieloetapowy proces potwierdzania tożsamości użytkownika. To, jak obecnie wygląda proces resetu hasła, pokazano na rysunku~\ref{fig:ui_password_reset}.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.95\linewidth]{rys03/pass_resert}
    \caption{Interfejs użytkownika wykorzystywany podczas resetowania hasła w „Harmony Home Net”}
    \label{fig:ui_password_reset}
\end{figure}

\noindent Samo resetowania hasła odbywa się według kroków:
\begin{itemize}
    \item \textbf{Prośba o reset hasła} -- użytkownik korzysta z sekcji \emph{Send Reset Link}, gdzie wprowadza swój adres e-mail i przesyła żądanie za pomocą przycisku \emph{Send Reset Link}. Po przesłaniu żądania na endpoint \texttt{/forgot-password} generowany jest unikalny token zabezpieczający, który zostaje wysłany na wskazany adres e-mail.
    
    \item \textbf{Resetowanie hasła} -- w sekcji \emph{Reset Password} użytkownik wprowadza nowe hasło, potwierdza je, a następnie wprowadza otrzymany token resetujący. Formularz przesyła dane na endpoint \texttt{/reset-password}, który weryfikuje token, sprawdza jego ważność oraz aktualizuje hasło w bazie danych.

    \item \textbf{Bezpieczeństwo} -- tokeny resetujące są jednorazowe i posiadają ograniczony czas ważności. Dodatkowo system wymusza spełnienie kryteriów bezpieczeństwa dla nowego hasła.

    \item \textbf{Zmiana hasła} -- dla zalogowanych użytkowników dostępny jest również dedykowany endpoint \texttt{/change-password}, który umożliwia zmianę hasła bez potrzeby resetowania, co zwiększa wygodę użytkowania systemu. Znajduję się o w panelu użytkownika w zakładce \textbf{,,Ustawienia''}
\end{itemize}


W przypadku produkcyjnych aplikacji mechanizmy resetowania hasła są bardziej rozbudowane. Proces ten obejmuje:
\begin{itemize}
    \item \emph{Wysłanie zabezpieczonego linku na e-mail} -- prośba o reset hasła generuje link zawierający jednorazowy token uwierzytelniający, wysyłany na adres e-mail użytkownika.
    \item \emph{Weryfikacja linku} -- po kliknięciu w link użytkownik zostaje przekierowany na stronę umożliwiającą ustawienie nowego hasła, gdzie token jest weryfikowany.
    \item \emph{Dodatkowe zabezpieczenia} -- ograniczenie czasowe ważności tokenu (np. 15 minut–1 godzina), szyfrowanie danych oraz logowanie operacji resetu w celu audytowania.
\end{itemize}

Jeśli chodzi o „Harmony Home Net”, to mechanizm resetowania hasła zaimplementowano z~użyciem kontrolera \texttt{AuthController} obsługującego endpointy o kodzie jak niżej.

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Fragment klasy \texttt{AuthController}]
@PostMapping("/forgot-password")
public ResponseEntity<String> forgotPassword(@RequestBody PasswordResetRequest request) {
    authService.forgotPassword(request.getEmail());
    return ResponseEntity.ok("Password reset link has been sent to your email.");
}

@PostMapping("/reset-password")
public ResponseEntity<String> resetPassword(@RequestBody PasswordUpdateRequest request) {
    authService.resetPassword(request.getToken(), request.getNewPassword(), request.getConfirmPassword());
    return ResponseEntity.ok("Password has been reset successfully.");
}

@PostMapping("/change-password")
public ResponseEntity<String> changePassword(@RequestBody PasswordChangeRequest request) {
    authService.changePassword(request.getNewPassword(), request.getConfirmPassword(), request.getEmail());
    return ResponseEntity.ok("Password has been changed successfully.");
}
\end{lstlisting}

\noindent Znaczenie poszczególnych endpointów jest następujące:
\begin{itemize}
\item \texttt{forgotPassword} -- generuje token resetujący, który jest wysyłany na podany adres e-mail użytkownika. Token ma ograniczoną ważność, co zwiększa bezpieczeństwo.
\item \texttt{resetPassword} -- weryfikuje token przesłany przez użytkownika, sprawdza jego ważność oraz zgodność przesłanych haseł. W przypadku pomyślnej walidacji hasło użytkownika jest aktualizowane w bazie.
\item \texttt{changePassword} -- pozwala na zmianę hasła dla zalogowanych użytkowników, weryfikując zgodność adresu e-mail i przesłanych danych.
\end{itemize}

Resetowania hasła jest realizowane przez klasę \texttt{AuthServiceImp}, która implementuje interfejs \texttt{AuthService}. Kluczowe metody odpowiedzialne za reset przedstwiono na listingu poniżej.
\begin{lstlisting}[language=Java, style=JavaStyle, caption=Metody resetowania hasła w klasie \texttt{AuthServiceImp}]
@Override
public void forgotPassword(String email) {
    User user = userRepository.findByEmail(email)
            .orElseThrow(() -> new UserNotFoundException("User not found"));

    String token = bCryptPasswordEncoder.encode(UUID.randomUUID().toString());
    user.setResetToken(token);
    user.setResetTokenExpiry(Instant.now().plus(1, ChronoUnit.HOURS));
    userRepository.save(user);

    mailService.sendNotificationMail(
            "Password Reset Request",
            token,
            user.getEmail()
    );
}

@Override
public void resetPassword(String token, String newPassword, String confirmPassword) {
    User user = userRepository.findByResetToken(token)
            .orElseThrow(() -> new ResponseStatusException(HttpStatus.BAD_REQUEST, "Invalid token"));

    if (!newPassword.equals(confirmPassword)) {
        throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Passwords do not match");
    }

    if (user.getResetTokenExpiry().isBefore(Instant.now())) {
        throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Token has expired");
    }

    user.setPassword(bCryptPasswordEncoder.encode(newPassword));
    user.setResetToken(null);
    user.setResetTokenExpiry(null);
    userRepository.save(user);
}
\end{lstlisting}

\noindent Działanie poszczególnych metod jest następujące:
\begin{itemize}
\item 
\texttt{forgotPassword(String email)} -- ta metoda generuje token resetowania hasła dla użytkownika z podanym adresem e-mail. W szczególności:
    \begin{enumerate}
        \item Sprawdza, czy użytkownik istnieje w bazie danych. Jeśli nie, rzuca wyjątek \texttt{UserNotFoundException}.
        \item Generuje unikalny token przy użyciu \texttt{UUID} i szyfruje go za pomocą algorytmu \texttt{BCrypt}.
        \item Ustawia token oraz datę jego wygaśnięcia (np. 1 godzina od momentu utworzenia) w obiekcie użytkownika.
        \item Wysyła wiadomość e-mail z tokenem i informacją o resetowaniu hasła za pomocą usługi \texttt{MailService}.
    \end{enumerate}
\item 
\texttt{resetPassword(String token, String newPassword, String confirmPassword)} -- ta metoda obsługuje resetowanie hasła na podstawie tokenu. Kluczowe kroki:
    \begin{enumerate}
        \item Pobiera użytkownika z bazy danych na podstawie przesłanego tokenu. Jeśli token jest nieprawidłowy, rzuca wyjątek \texttt{ResponseStatusException}.
        \item Sprawdza, czy nowe hasło oraz jego potwierdzenie są zgodne. W przypadku niezgodności rzuca wyjątek \texttt{BAD\_REQUEST}.
        \item Weryfikuje ważność tokenu, porównując jego datę wygaśnięcia z bieżącym czasem.
        \item Aktualizuje hasło użytkownika, resetuje token oraz jego datę ważności w bazie danych.
    \end{enumerate}
\end{itemize}

\noindent \textbf{Implementacja czyszczenia wygasłych tokenów}\newline
Aby zapewnić bezpieczeństwo i efektywne zarządzanie bazą danych, w systemie zaimplementowano usługę \texttt{TokenCleanupService}, która regularnie usuwa wygasłe tokeny resetujące hasła. Kluczowe elementy implementacji:
\begin{itemize}
    \item Usługa korzysta z adnotacji \texttt{@Scheduled}, aby wykonywać zadanie czyszczenia co 30 minut.
    \item Metoda \texttt{cleanUpExpiredResetTokens} usuwa tokeny wygasłe w oparciu o bieżący czas.
    \item Usługa działa asynchronicznie, dzięki adnotacji \texttt{@Async} nie blokuje innych operacji.
\end{itemize}

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Usługa czyszczenia wygasłych tokenów \texttt{TokenCleanupService}]
@Service
@RequiredArgsConstructor
public class TokenCleanupService {

    private final UserRepository userRepository;

    @Scheduled(cron = "0 0/30 * * * *") // Co 30 minut
    @Async
    public void cleanUpExpiredResetTokens() {
        userRepository.deleteAllExpiredResetTokens(Instant.now());
    }

}
\end{lstlisting}
Podsumowując główne cechy implementacji:
\begin{itemize}
    \item \textbf{Token jest ważny czasowo} -- tokeny resetujące hasło mają ograniczony czas ważności, co minimalizuje ryzyko nieautoryzowanego użycia.
    \item \textbf{Usuwanie wygasłych tokenów odbywa się regularnie} -- mechanizm automatycznego czyszczenia zapewnia, że baza danych pozostaje wolna od nieaktualnych tokenów.
\end{itemize}

\noindent \textbf{Bezpieczeństwo i walidacja}\newline
Każdy krok w procesie resetowania hasła jest zabezpieczony odpowiednimi walidacjami:
\begin{enumerate}
    \item Token jest szyfrowany i przechowywany w bazie danych, co uniemożliwia jego odczytanie w przypadku naruszenia bezpieczeństwa bazy.
    \item Token ma ograniczoną ważność, co minimalizuje ryzyko jego wykorzystania po upływie określonego czasu.
    \item Sprawdzana jest zgodność nowego hasła i jego potwierdzenia, aby uniknąć przypadkowych błędów ze strony użytkownika.
\end{enumerate}

\noindent \textbf{Rozszerzenie funkcjonalności w przyszłości}\newline
W przyszłości mechanizm może zostać rozszerzony o dodatkowe funkcje, takie jak:
\begin{enumerate}
    \item Logowanie operacji resetowania hasła w celu audytowania.
    \item Dodanie wieloskładnikowego uwierzytelniania (MFA) podczas resetowania hasła.
    \item Wysyłanie linku resetującego, który odsyła użytkownika na dedykowaną stronę, zamiast przesyłania samego tokenu w wiadomości.
\end{enumerate}

\noindent \textbf{Bezpieczeństwo i wygoda użytkownika}\newline 
Mechanizmy te, choć uproszczone w prototypie, zapewniają podstawowy poziom bezpieczeństwa, jednocześnie umożliwiając wygodne resetowanie hasła. W przyszłości aplikacja może zostać rozszerzona o dodatkowe zabezpieczenia, takie jak wieloskładnikowe uwierzytelnianie (MFA) lub mechanizmy monitorujące nieautoryzowane próby resetowania hasła.


\section{Zarządzanie użytkownikami}

System zarządzania użytkownikami w prototypie \textbf{Harmony Home Net} został zaprojektowany jako zamknięty system, co oznacza, że proces rejestracji nowych użytkowników odbywa się wyłącznie z poziomu pracownika administracyjnego. Brak publicznego systemu rejestracji użytkowników jest zamierzonym rozwiązaniem, mającym na celu zwiększenie bezpieczeństwa systemu oraz ograniczenie dostępu jedynie do osób upoważnionych. 

\subsection{Encja użytkownika \texttt{User}}

Encja \texttt{User} jest jednym z dwóch centralnym elementem systemu zarządzania użytkownikami. Reprezentuje dane użytkownika w systemie, takie jak imię, nazwisko, adres e-mail, numer telefonu oraz przypisana rola. Klasa \texttt{User} implementuje interfejs \texttt{UserDetails} z biblioteki Spring Security, co umożliwia jej bezpośrednie wykorzystanie w procesie autoryzacji i uwierzytelniania użytkowników. Kluczowe cechy encji \texttt{User} to:
\begin{itemize}
    \item \textbf{Implementacja \texttt{UserDetails}} -- dzięki implementacji interfejsu \texttt{UserDetails}, encja \texttt{User} jest zintegrowana z mechanizmami Spring Security, które wykorzystują ją do przechowywania i zarządzania danymi uwierzytelniającymi.
    \item \textbf{Adnotacje JPA} -- encja jest zmapowana na tabelę \texttt{Users} w bazie danych przy użyciu adnotacji JPA, takich jak \texttt{@Entity}, \texttt{@Table} oraz \texttt{@Column}.
    \item \textbf{Powiązania z innymi encjami} -- encja posiada relacje z wieloma innymi tabelami, takimi jak \texttt{NotificationType}, \texttt{UserDocumentConnection} oraz \texttt{PossessionHistory}, które odzwierciedlają jej złożoną strukturę w systemie.
    \item \textbf{Zabezpieczenia danych} -- pola, takie jak hasło (\texttt{Password}), są odpowiednio walidowane i szyfrowane przed zapisaniem w bazie danych.
\end{itemize}
Poniżej zamieszczono fragment kodu encji \texttt{User}.
\begin{lstlisting}[language=Java, style=JavaStyle, caption=Encja użytkownika \texttt{User}]
@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Entity
@Table(name = "Users", indexes = {
	@Index(name = "idx_user_email_unq", columnList = "Email", unique = true),
	@Index(name = "idx_user_uuid", columnList = "UUID_id", unique = true)
})
public class User implements UserDetails {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "UUID_id")
    private UUID uuidID;

    @NotEmpty
    @Size(min = 3, max = 50)
    @Column(name = "First_name", nullable = false, length = 50)
    private String firstName;

    @NotEmpty
    @Size(min = 3, max = 50)
    @Column(name = "Last_name", nullable = false, length = 50)
    private String lastName;

    @NotEmpty
    @Email
    @Pattern(regexp = "^[A-Za-z0-9+_.-]+@(.+)$", message = "Invalid email format")
    @Column(name = "Email", nullable = false, unique = true, length = 50)
    private String email;

    @NotEmpty
    @Size(min = 10, max = 255)
    @Column(name = "Password", nullable = false)
    private String password;

    @Column(name = "Role", length = 20)
    @Enumerated(EnumType.STRING)
    private Role role;

    @NotEmpty
    @Pattern(regexp = "^\\d{9,11}$", message = "Invalid phone number format")
    @Column(name = "Phone_number", nullable = false, unique = true, length = 11)
    private String phoneNumber;

    @CreationTimestamp
    @Column(name = "Create_at")
    private Instant createdAt;

    @UpdateTimestamp
    @Column(name = "Update_at")
    private Instant updatedAt;

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    @JsonManagedReference
    private List<NotificationType> notificationTypes;

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    @JsonManagedReference
    private List<UserDocumentConnection> userDocumentConnections;

    @Column(name = "reset_token")
    private String resetToken;

    @Column(name = "reset_token_expiry")
    private Instant resetTokenExpiry;

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return List.of(role);
    }

    @Override
    public String getPassword() {
        return password;
    }

    @Override
    public String getUsername() {
        return email;
    }
}
\end{lstlisting}

\textbf{Rola w procesie autoryzacji} -- dzięki implementacji metody \texttt{getAuthorities()} z interfejsu \texttt{UserDetails}, encja \texttt{User} umożliwia Spring Security odczytywanie ról przypisanych użytkownikowi. To pozwala na efektywne zarządzanie dostępem do zasobów w systemie i egzekwowanie polityk bezpieczeństwa na podstawie ról użytkowników.


\subsection{Role i poziomy dostępu}

System zarządzania użytkownikami opiera się na hierarchii ról, które są zdefiniowane w klasie \texttt{Role}. Dzięki temu system może łatwo określić, czy użytkownik posiada wystarczające uprawnienia do wykonania określonej operacji, takiej jak edycja danych innego użytkownika czy przypisanie nowej roli. Role zdefiniowane w systemie to:
\begin{itemize}
    \item \texttt{ROLE\_OWNER} -- poziom 1, właściciel mieszkania, podstawowa rola w systemie.
    \item \texttt{ROLE\_EMPLOYEE} -- poziom 2, pracownik administracyjny.
    \item \texttt{ROLE\_ADMIN} -- poziom 3, administrator systemu.
    \item \texttt{ROLE\_SUPER\_ADMIN} -- poziom 4, najwyższy poziom dostępu, superadministrator.
\end{itemize}
\noindent \textbf{Działanie hierarchii ról}
\begin{itemize}
    \item Każda rola ma wartość liczbową (\texttt{level}), określającą jej miejsce w hierarchii uprawnień.
    \item Funkcje takie jak przypisywanie nowych ról czy edycja danych sprawdzają, czy użytkownik wykonujący operację posiada wyższy lub równy poziom dostępu (\texttt{level}) w stosunku do użytkownika, którego dane mają być zmodyfikowane.
    \item Rola \texttt{ROLE\_OWNER} jest specjalnie zabezpieczona, aby zapobiec jej zmianie na inną rolę bez uprzedniego usunięcia użytkownika i ponownej rejestracji.
\end{itemize}
Poniżej zamieszczono fragment kodu definiującego enumerację \texttt{Role}.
\begin{lstlisting}[language=Java, style=JavaStyle, caption=Definicja ról w systemie \texttt{Role}]
package bwp.hhn.backend.harmonyhomenetlogic.utils.enums;

import lombok.Getter;
import org.springframework.security.core.GrantedAuthority;

@Getter
public enum Role implements GrantedAuthority {
    ROLE_OWNER(1), ROLE_EMPLOYEE(2), ROLE_ADMIN(3), ROLE_SUPER_ADMIN(4);

    private final int level;

    Role(int level) {
        this.level = level;
    }

    @Override
    public String getAuthority() {
        return name();
    }
}
\end{lstlisting}




\subsection{Dodawanie użytkowników i przypisywanie ról}

Proces zarządzania użytkownikami, w tym ich dodawanie i edycja, jest realizowany za pomocą prostego mechanizmu autoryzacji opartego na wartościach liczbowych przypisanych do ról w enumeracji \texttt{Role}. Każda rola (np. \texttt{ROLE\_OWNER}, \texttt{ROLE\_EMPLOYEE}, \texttt{ROLE\_ADMIN}) ma przypisany poziom dostępu, który określa możliwość wykonywania operacji takich jak dodawanie, edytowanie czy usuwanie użytkowników. Mechanizm ten wymaga, aby poziom dostępu osoby wykonującej daną operację był równy lub wyższy od poziomu użytkownika, na którym operacja ma być wykonana.

\textbf{Kluczowe założenia mechanizmu:}
\begin{itemize}
    \item \textbf{Hierarchia poziomów dostępu} -- wartości liczbowe przypisane do ról zapewniają, że np. użytkownik z rolą \texttt{ROLE\_ADMIN} może edytować użytkowników z rolami o niższym poziomie, ale nie może przypisać im roli o poziomie wyższym od swojego.
    \item \textbf{Zabezpieczenie ról} -- rola \texttt{ROLE\_OWNER} jest szczególnie chroniona – nie można zmienić jej na inną rolę, taką jak \texttt{ROLE\_EMPLOYEE} lub \texttt{ROLE\_ADMIN}, i odwrotnie. Aby dokonać takiej zmiany, konieczne jest usunięcie użytkownika i ponowne dodanie go z nową rolą.
\end{itemize}

Proces rejestracji użytkownika został zaimplementowany w usłudze \texttt{AuthServiceImp}, a jego kluczowe elementy to:
\begin{itemize}
    \item \textbf{Weryfikacja dostępu pracownika rejestrującego} -- Przy każdej rejestracji token JWT dostarczony przez pracownika jest weryfikowany, aby upewnić się, że osoba rejestrująca ma odpowiednie uprawnienia do przypisania nowego użytkownika i jego roli.
    \item \textbf{Przypisywanie ról} -- Użytkownikowi można przypisać jedną z dostępnych ról (\texttt{ROLE\_OWNER}, \texttt{ROLE\_EMPLOYEE}, \texttt{ROLE\_ADMIN}, \texttt{ROLE\_SUPER\_ADMIN}). Każda rola ma określony poziom dostępu, co zapobiega nadawaniu wyższych ról przez osoby z niższymi uprawnieniami.
    \item \textbf{Wysyłanie powitalnego e-maila} -- Po poprawnym zapisaniu użytkownika w bazie danych, na jego adres e-mail wysyłana jest wiadomość powitalna za pomocą usługi \texttt{MailService}.
\end{itemize}

Fragment kodu obsługującego rejestrację użytkownika:
\begin{lstlisting}[language=Java, style=JavaStyle, caption=Rejestracja użytkownika w \texttt{AuthServiceImp}]
@Override
@Transactional
public String register(RegisterRequest userRequest, String accessToken) {
    JwtDecoder jwtDecoder = NimbusJwtDecoder.withPublicKey(rsaKeyRecord.publicKey()).build();
    final Jwt jwtToken = jwtDecoder.decode(accessToken);

    Role role = Role.valueOf(jwtToken.getClaim("role"));

    if (role.getLevel() < userRequest.getRole().getLevel()) {
        throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, "Insufficient permissions to update or assign the role");
    }

    if (userRepository.existsByEmail(userRequest.getEmail())) {
        throw new ResponseStatusException(HttpStatus.CONFLICT, "Email already exists");
    }

    User user = User.builder()
            .email(userRequest.getEmail())
            .password(bCryptPasswordEncoder.encode(userRequest.getPassword()))
            .role(userRequest.getRole())
            .firstName(userRequest.getFirstName())
            .lastName(userRequest.getLastName())
            .phoneNumber(userRequest.getPhoneNumber())
            .build();

    userRepository.save(user);
    mailService.sendNotificationMail("Welcome to Harmony Home Net", "Your account has been successfully created.", user.getEmail());
    return "User registered successfully.";
}
\end{lstlisting}

\subsection{Zarządzanie użytkownikami i ich danymi}

Funkcjonalność zarządzania użytkownikami obejmuje:
\begin{itemize}
    \item \textbf{Paginację} -- dla efektywnego zarządzania dużą liczbą użytkowników, zaimplementowano mechanizm stronicowania (\texttt{Pagination}), który umożliwia pobieranie danych w mniejszych porcjach.
    \item \textbf{Edycja danych użytkownika} -- administratorzy mogą zmieniać dane użytkowników, takie jak e-mail, imię, nazwisko czy rola.
    \item \textbf{Usuwanie użytkowników} -- system pozwala na usuwanie użytkowników wraz z powiązanymi danymi, takimi jak powiadomienia czy głosy.
\end{itemize}

\textbf{Fragment kodu obsługującego edycję użytkownika:}
\begin{lstlisting}[language=Java, style=JavaStyle, caption=Edycja użytkownika w \texttt{UserServiceImp}]
@Override
public UserResponse updateUser(UUID userId, UserRequest user, String accessToken) throws UserNotFoundException {
    JwtDecoder jwtDecoder = NimbusJwtDecoder.withPublicKey(rsaKeyRecord.publicKey()).build();
    final Jwt jwtToken = jwtDecoder.decode(accessToken);

    Role role = Role.valueOf(jwtToken.getClaim("role"));

    if (role.getLevel() < user.getRole().getLevel()) {
        throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, "Insufficient permissions to update or assign the role");
    }

    User userEntity = userRepository.findByUuidIDOrEmail(userId, null)
            .orElseThrow(() -> new UserNotFoundException("User id: " + userId + " not found"));

    if (userEntity.getRole() == Role.ROLE_OWNER && user.getRole() != Role.ROLE_OWNER) {
        throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, "Cannot change the role of an OWNER");
    }

    if ((userEntity.getRole() == Role.ROLE_ADMIN || userEntity.getRole() == Role.ROLE_EMPLOYEE) && user.getRole() == Role.ROLE_OWNER) {
        throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, "Cannot change the role to OWNER");
    }

    userEntity.setEmail(user.getEmail() != null ? user.getEmail() : userEntity.getEmail());
    userEntity.setFirstName(user.getFirstName() != null ? user.getFirstName() : userEntity.getFirstName());
    userEntity.setLastName(user.getLastName() != null ? user.getLastName() : userEntity.getLastName());
    userEntity.setPhoneNumber(user.getPhoneNumber() != null ? user.getPhoneNumber() : userEntity.getPhoneNumber());
    userEntity.setRole(user.getRole() != null ? user.getRole() : userEntity.getRole());
    userEntity.setPassword(user.getPassword() != null ? bCryptPasswordEncoder.encode(user.getPassword()) : userEntity.getPassword());

    User saved = userRepository.save(userEntity);

    return UserResponse.builder()
            .email(saved.getEmail())
            .firstName(saved.getFirstName())
            .lastName(saved.getLastName())
            .updatedAt(saved.getUpdatedAt())
            .createdAt(saved.getCreatedAt())
            .phoneNumber(saved.getPhoneNumber())
            .build();
}
\end{lstlisting}


Fragment kontrolera odpowiedzialnego za paginację i zarządzanie użytkownikami:
\begin{lstlisting}[language=Java, style=JavaStyle, caption=Metoda paginacji w \texttt{UserController}]
@GetMapping("/get-all-users")
public ResponseEntity<PageResponse<UserResponse>> getAllUsers(
        @RequestParam(value = "pageNo", defaultValue = "0", required = false) int pageNo,
        @RequestParam(value = "pageSize", defaultValue = "10", required = false) int pageSize) {
    return ResponseEntity.ok(userService.getAllUsers(pageNo, pageSize));
}
\end{lstlisting}

\subsection{Przyszłe usprawnienia: integracja ACL}

Jednym z możliwych kierunków rozwoju systemu jest integracja mechanizmu \textbf{ACL}~\cite{acl}. ACL umożliwia bardziej precyzyjne zarządzanie dostępem do zasobów poprzez przypisywanie uprawnień na poziomie pojedynczych zasobów (np. użytkownik może edytować tylko swoje zgłoszenia techniczne, ale nie ma dostępu do zgłoszeń innych właścicieli). Dzięki temu system mógłby zapewniać większą elastyczność i bezpieczeństwo przy zarządzaniu użytkownikami.

ACL w przyszłości może obejmować:
\begin{itemize}
    \item Definiowanie uprawnień na poziomie obiektów (np. dostęp do konkretnego mieszkania).
    \item Tworzenie hierarchii uprawnień dostosowanych do struktury organizacyjnej wspólnoty mieszkaniowej.
    \item Logowanie i audyt działań użytkowników w celu monitorowania potencjalnych nadużyć.
\end{itemize}

W obecnym prototypie systemu, zarządzanie użytkownikami i przypisywanie ról stanowi solidną podstawę, którą można rozbudować o bardziej zaawansowane mechanizmy, takie jak ACL, w przyszłych wersjach aplikacji.


\section{Zarządzanie mieszkaniami}

Zarządzanie mieszkaniami w prototypie systemu ,,Harmony Home Net'' jest kluczowym elementem jego funkcjonalności. Mieszkanie stanowi jedną z dwóch podstawowych tabel w systemie, obok tabeli użytkowników. W ramach tej sekcji omówione zostaną szczegóły implementacyjne, w tym struktura encji, tabela pośrednicząca \texttt{PossessionHistory}, sposób zarządzania mieszkaniami, właścicielami oraz przyszłe funkcje, które mogą zostać zaimplementowane.

\subsection{Encja \texttt{Apartment}}

Encja \texttt{Apartment} reprezentuje mieszkanie w systemie. Każdy rekord zawiera informacje takie jak adres, powierzchnia, wartość procentowa oraz sygnatura unikalna dla każdego mieszkania. Struktura encji jest następująca:

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Encja mieszkania \texttt{Apartment}]
@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Entity
@Table(name = "Apartments", indexes = {
        @Index(name = "idx_apartment_unq", columnList = "Apartment_signature", unique = true)
})
public class Apartment {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "UUID_id")
    private UUID uuidID;

    @NotNull
    @Size(min = 1, max = 60)
    @Column(name = "Apartment_signature", nullable = false, unique = true, length = 60)
    private String apartmentSignature;

    @NotEmpty
    @Size(max = 50)
    @Column(name = "Address", nullable = false, length = 50)
    private String address;

    @NotEmpty
    @Size(max = 20)
    @Column(name = "City", nullable = false, length = 20)
    private String city;

    @NotEmpty
    @Pattern(regexp = "^\\d{2}-\\d{3}$", message = "Invalid zip code format")
    @Column(name = "Zip_code", nullable = false, length = 6)
    private String zipCode;

    @NotNull
    @DecimalMin(value = "0.0", inclusive = false)
    @Digits(integer = 3, fraction = 2)
    @Column(name = "Apartment_area", nullable = false, precision = 5, scale = 2)
    private BigDecimal apartmentArea;

    @NotNull
    @DecimalMin(value = "0.0", inclusive = false)
    @Column(name = "Apartment_percent_value", nullable = false, precision = 5, scale = 2)
    private BigDecimal apartmentPercentValue;

    @CreationTimestamp
    @Column(name = "Create_at", nullable = false, updatable = false)
    private Instant createdAt;

    @UpdateTimestamp
    @Column(name = "Update_at", updatable = false)
    private Instant updatedAt;

    @OneToMany(mappedBy = "apartment", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<PossessionHistory> possessionHistories;

    // Additional relationships and fields
}
\end{lstlisting}

\subsection{Tabela pośrednicząca \texttt{PossessionHistory}}

Tabela \texttt{PossessionHistory} umożliwia zarządzanie relacjami pomiędzy użytkownikami a mieszkaniami. Zawiera informacje o tym, które mieszkania są aktualnie przypisane do jakich użytkowników oraz historię przypisań. Struktura tabeli zapewnia unikalność pary użytkownik-mieszkanie.

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Tabela pośrednicząca \texttt{PossessionHistory}]
@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Entity
@Table(name = "Possession_history", indexes = {
        @Index(name = "idx_possession_user_id", columnList = "user_id"),
        @Index(name = "idx_possession_apartment_id", columnList = "apartment_id"),
        @Index(name = "idx_possession_start_date", columnList = "start_date"),
        @Index(name = "idx_possession_end_date", columnList = "end_date")
}, uniqueConstraints = {
        @UniqueConstraint(columnNames = {"user_id", "apartment_id"})
})
public class PossessionHistory {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID")
    private Long id;

    @CreationTimestamp
    @Column(name = "Start_date", nullable = false)
    private Instant startDate;

    @Column(name = "End_date")
    private Instant endDate;

    @Column(name = "Status_notes", length = 1000)
    private String statusNotes;

    @ManyToOne
    @JoinColumn(name = "user_id", referencedColumnName = "UUID_id")
    private User user;

    @ManyToOne
    @JoinColumn(name = "apartment_id", referencedColumnName = "UUID_id")
    private Apartment apartment;
}
\end{lstlisting}

\subsection{Przypisywanie i odłączanie właścieli}

Proces przypisywania mieszkania do użytkownika jest realizowany w serwisie \texttt{ApartmentsServiceImp}. Przykładowa implementacja:

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Przypisywanie właścicieli w \texttt{ApartmentsServiceImp}]
@Override
@Transactional
public PossessionHistoryResponse createPossessionHistory(String apartmentSignature, UUID userId)
        throws ApartmentNotFoundException, UserNotFoundException {
    User user = userRepository.findById(userId)
            .orElseThrow(() -> new UserNotFoundException("User: " + userId + " not found"));

    Apartment apartment = apartmentsRepository.findByApartmentSignature(apartmentSignature)
            .orElseThrow(() -> new ApartmentNotFoundException("Apartment with signature: " + apartmentSignature + " not found"));

    if (possessionHistoryRepository.existsByUserUuidIDAndApartmentUuidID(userId, apartment.getUuidID())) {
        throw new ApartmentNotFoundException("User already has this apartment assigned");
    }

    PossessionHistory possessionHistory = PossessionHistory.builder()
            .user(user)
            .apartment(apartment)
            .build();

    PossessionHistory saved = possessionHistoryRepository.save(possessionHistory);

    return PossessionHistoryResponse.builder()
            .userName(saved.getUser().getFirstName() + " " + saved.getUser().getLastName())
            .apartmentName(saved.getApartment().getAddress())
            .startDate(saved.getStartDate())
            .build();
}
\end{lstlisting}

\subsection{Przyszłe usprawnienia dla zarządzania właścielami}

Aktualnie proces dodawania i usuwania właścicieli mieszkań na warstwie frontendowej jest zrealizowany w sposób bardzo uproszony. Użytkownik musi ręcznie wprowadzić UUID osoby, która ma zostać przypisana jako właściciel mieszkania, co jest niepraktyczne i podatne na błędy w przypadku dużej liczby użytkowników.

Proponowane usprawnienia obejmują:

\begin{itemize}
    \item \textbf{Lista wyliczeniowa użytkowników} -- Zastąpienie ręcznego wpisywania UUID możliwością wyboru użytkownika z listy dostępnych właścicieli. Lista mogłaby wyświetlać podstawowe informacje o użytkownikach, takie jak imię, nazwisko, e-mail czy numer telefonu.
    \item \textbf{Filtry wyszukiwania} -- wprowadzenie mechanizmu filtrów, który umożliwiłby wyszukiwanie użytkowników na podstawie określonych kryteriów, takich jak rola, adres e-mail czy numer telefonu.
    \item \textbf{Intuicyjny interfejs} -- dodanie opcji podglądu szczegółowych informacji o użytkowniku bez opuszczania ekranu zarządzania mieszkaniami.
\end{itemize}

W przyszłości planowane jest rozszerzenie systemu o następujące funkcje:
\begin{itemize}
    \item \textbf{Automatyczne generowanie powiadomień} -- informowanie właścicieli o zmianach statusu mieszkania.
    \item \textbf{Zaawansowana historia posiadania} -- dodanie możliwości załączania notatek i dokumentów do historii posiadania.
    \item \textbf{Integracja z systemami księgowymi} -- automatyczne generowanie opłat na podstawie powierzchni mieszkania i jego wartości procentowej.
\end{itemize}

Dzięki tym zmianom proces zarządzania właścicielami mieszkań stanie się bardziej intuicyjny i mniej podatny na błędy. Dodatkowo, lepsza prezentacja danych na froncie pozwoli pracownikom administracyjnym szybciej i sprawniej realizować operacje związane z przypisywaniem właścicieli.


\section{Zarządzie dokumentami}

\subsection{Opis encji i relacji}

\textbf{Encja \texttt{Document}}  -- jest kluczowym elementem systemu zarządzania dokumentami, przechowując dane niezbędne do identyfikacji i obsługi dokumentów w systemie. Kod odpowiadającej jej klasy przedstawiono poniżej.
\begin{lstlisting}[language=Java, style=JavaStyle, caption=Encja \texttt{Document}]
@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Entity
@Table(name = "Documents")
public class Document {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "UUID_id")
    private UUID uuidID; 

    @NotEmpty
    @Size(max = 50)
    @Column(name = "Document_name", nullable = false, unique = true, length = 50)
    private String documentName; 

    @NotEmpty
    @Size(max = 8)
    @Column(name = "Document_extension", nullable = false, length = 8)
    private String documentExtension;
    @NonNull
    @Enumerated(EnumType.STRING)
    @Column(name = "Document_type", nullable = false)
    private DocumentType documentType; 

    @Lob
    @NotNull
    @Column(name = "Document_data", nullable = false)
    private byte[] documentData;

    @CreationTimestamp
    @Column(name = "Created_at", nullable = false, updatable = false)
    private Instant createdAt; 

    @OneToMany(mappedBy = "document", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<UserDocumentConnection> userDocumentConnections; 
}
\end{lstlisting}

\noindent Znaczenie atrybutów klasy:
\begin{itemize}
    \item \texttt{uuidID} -- unikalny identyfikator UUID każdego dokumentu, generowany automatycznie,
    \item \texttt{documentName} -- nazwa dokumentu, wymagana i unikalna w systemie,
    \item \texttt{documentExtension} -- rozszerzenie pliku, wskazujące format przechowywanego dokumentu,
    \item \texttt{documentType} -- typ dokumentu zdefiniowany w enumeracji \texttt{DocumentType},
    \item \texttt{documentData} -- dane dokumentu zapisane w postaci tablicy bajtów,
    \item \texttt{createdAt} -- znacznik czasu wskazujący moment dodania dokumentu do systemu,
    \item \texttt{userDocumentConnections} -- lista obiektów reprezentujących relacje z użytkownikami.
\end{itemize}

\textbf{Encja \texttt{UserDocumentConnection}} -- tabela pośrednicząca \texttt{UserDocumentConnection} zarządza relacją między dokumentami a użytkownikami, którzy mają do nich dostęp. Kod odpowiadającej jej klasy przedstawiono poniżej.
\begin{lstlisting}[language=Java, style=JavaStyle, caption=Encja \texttt{UserDocumentConnection}]
@Entity
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "user_documents_connections", uniqueConstraints = {
        @UniqueConstraint(columnNames = {"documents_id", "users_id"})
})
public class UserDocumentConnection {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID uuidID;

    @ManyToOne
    @JoinColumn(name = "documents_id", nullable = false)
    private Document document;

    @ManyToOne
    @JoinColumn(name = "users_id", nullable = false)
    private User user;

    @CreationTimestamp
    @Column(name = "granted_at", nullable = false)
    private Instant grantedAt;
}
\end{lstlisting}

\noindent Znaczenie atrybutów klasy:
\begin{itemize}
    \item \texttt{uuidID} -- unikalny identyfikator każdego rekordu w tabeli pośredniczącej,
    \item \texttt{document} -- pole relacyjne wskazujące na powiązany dokument,
    \item \texttt{user} -- pole relacyjne wskazujące na powiązanego użytkownika,
    \item \texttt{grantedAt} -- data przyznania dostępu użytkownikowi do dokumentu.
\end{itemize}

\subsection{Rodzaje dokumentów}
Rodzaje dokumentów w systemie są zdefiniowane w enumeracji \texttt{DocumentType}, która umożliwia kategoryzację dokumentów. Definicja wygląda następująco:

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Enumeracja \texttt{DocumentType}]
public enum DocumentType {
    RESOLUTION,    // Uchwały.
    DECISION,      // Decyzje.
    PROPERTY_DEED, // Akty własności (prywatne).
    OTHER          // Inne dokumenty.
}
\end{lstlisting}

W systemie wszystkie dokumenty, które nie są typu \texttt{PROPERTY\_DEED}, są publiczne i dostępne dla każdego użytkownika.

\subsection{Przepływ dokumentów w systemie ,,Harmony Home Net''}

W prototypie systemu „Harmony Home Net” przepływ dokumentów został uproszczony:

\begin{figure}[h]
    \centering
    \includegraphics[width=.8\linewidth]{rys03/dodawanie_dokumentów_schemat}
    \caption{Schemat dodawania dokumentów w systemie „Harmony Home Net”}
    \label{fig:document_schema}
\end{figure}

Na schemacie ~\ref{fig:document_schema} oznaczono:
\begin{itemize}
    \item \texttt{D} -- Encja \texttt{Document}, reprezentująca dokument w systemie. Każdy dokument zawiera informacje o nazwie, typie, rozszerzeniu i danych pliku.
    \item \texttt{D\_Pub} -- Dokumenty publiczne, które są automatycznie przypisywane do wszystkich użytkowników w systemie, np. decyzje lub uchwały.
    \item \texttt{D\_Priv} -- Dokumenty prywatne (\texttt{PROPERTY\_DEED}), które są przypisywane wyłącznie właścicielom mieszkań na podstawie historii posiadania (\texttt{Ph}).
    \item \texttt{U} -- Encja \texttt{User}, reprezentująca użytkownika systemu. Każdy użytkownik może mieć przypisane dokumenty zarówno publiczne, jak i prywatne.
    \item \texttt{Ph} -- Tabela \texttt{PossessionHistory}, zawierająca informacje o historii posiadania mieszkań przez użytkowników, co umożliwia precyzyjne przypisanie dokumentów prywatnych.
    \item \texttt{A} -- Encja \texttt{Apartment}, reprezentująca mieszkanie w systemie. Sygnatura mieszkania jest kluczowa przy przypisywaniu dokumentów prywatnych.
\end{itemize}

Opis procesu dodawania dokumentów:
\begin{enumerate}
    \item Dokument jest dodawany przez administratora lub pracownika systemu poprzez endpoint upload (\texttt{/upload-document}). W tym procesie określane są szczegóły dokumentu, takie jak jego typ oraz opcjonalne powiązanie z mieszkaniem (\texttt{A}).
    \item Dokumenty publiczne (\texttt{D\_Pub}) są automatycznie przypisywane do wszystkich użytkowników w systemie. Mechanizm ten działa zarówno w momencie dodawania dokumentu, jak i tworzenia nowego użytkownika.
    \item Dokumenty prywatne (\texttt{D\_Priv}) są przypisywane na podstawie tabeli \texttt{PossessionHistory} (\texttt{Ph}) do właścicieli mieszkań (\texttt{A}). Proces ten wymaga podania sygnatury mieszkania, co umożliwia precyzyjne przypisanie dokumentu do odpowiednich użytkowników.
    \item W przypadku zmiany właściciela mieszkania lub dodania współwłaściciela:
    \begin{itemize}
        \item Połączenie dokumentu prywatnego z dotychczasowym właścicielem może zostać usunięte, jednak sam dokument pozostaje w archiwum.
        \item Nowy dokument, odzwierciedlający zmienione prawa własności, jest dodawany do systemu, a odpowiednie połączenia z użytkownikami są aktualizowane.
    \end{itemize}
\end{enumerate}

\noindent Schemat~\ref{fig:document_schema} przedstawia też trzy główne przypadki związane z dodawaniem dokumentów:
\begin{itemize}
    \item \texttt{a)} -- dodanie nowego dokumentu do systemu: Wymaga określenia rodzaju dokumentu (\texttt{D\_Pub} lub \texttt{D\_Priv}). Dokument publiczny automatycznie łączy się z wszystkimi użytkownikami (\texttt{U}), natomiast dokument prywatny jest przypisywany do użytkowników na podstawie historii posiadania (\texttt{Ph}).
    \item \texttt{b)} -- dodanie nowego użytkownika do systemu: Wszystkie istniejące dokumenty publiczne (\texttt{D\_Pub}) są automatycznie przypisywane nowemu użytkownikowi (\texttt{U}).
    \item \texttt{c)} -- zmiana właściciela mieszkania: W przypadku dokumentów prywatnych (\texttt{D\_Priv}), konieczne jest zaktualizowanie połączeń dokumentu z użytkownikami na podstawie nowej historii posiadania (\texttt{Ph}). W takiej sytuacji usuwa się stare połączenia i dodaje nowe, zgodnie z aktualnym stanem prawnym.
\end{itemize}

Poniżej zamieszczono fragment kodu kontrolera oraz serwisu.
\begin{lstlisting}[language=Java, style=JavaStyle, caption=Fragment klasy \texttt{DocumentController}]
@PostMapping("/upload-document")
public ResponseEntity<DocumentResponse> uploadDocument(
        @RequestPart("file") MultipartFile file,
        @RequestParam String apartmentSignature,
        @RequestParam DocumentType documentType) throws IllegalArgumentException, IOException {
    return ResponseEntity.ok(documentService.uploadDocument(file, apartmentSignature, documentType));
}
\end{lstlisting}

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Metoda dodawania dokumentu w klasie \texttt{DocumentServiceImp}]
@Override
@Transactional
public DocumentResponse uploadDocument(MultipartFile file, String apartmentSignature, DocumentType documentType) throws IllegalArgumentException, IOException {

		// Tworzenie nowego obiektu dokumentu
		Document documentEntity = Document.builder()
						.documentName(getOriginalFileNameWithoutExtension(file.getOriginalFilename()))
						.documentData(file.getBytes())
						.documentType(documentType)
						.documentExtension(getFileExtension(file.getOriginalFilename()))
						.build();

		// Zapis dokumentu w repozytorium
		documentRepository.save(documentEntity);

		// Pobranie użytkowników do przypisania w zależności od typu dokumentu
		List<User> eligibleUsers;
		if (!documentType.equals(DocumentType.PROPERTY_DEED)) {
				// Dokument publiczny - przypisujemy wszystkich użytkowników
				eligibleUsers = userRepository.findAll();
		} else {
				// Dokument prywatny - pobierz właścieli apartamentu i pracowników oraz adminów
				List<User> residents = possessionHistoryRepository.findActiveResidentsByApartment(apartmentSignature);

				if (residents.isEmpty()) {
						throw new IllegalArgumentException("No residents found in apartment with signature: " + apartmentSignature);
				}

				List<User> employees = userRepository.findAllByRole(Role.ROLE_EMPLOYEE);
				List<User> admins = userRepository.findAllByRole(Role.ROLE_ADMIN);

				eligibleUsers = new ArrayList<>(residents);
				eligibleUsers.addAll(employees);
				eligibleUsers.addAll(admins);
		}

		// Tworzenie połączeń dokumentu z wybranymi użytkownikami
		List<UserDocumentConnection> connections = new ArrayList<>();
		for (User user : eligibleUsers) {
				// Sprawdzenie, czy połączenie już istnieje
				if (userDocumentConnectionRepository.existsByDocumentUuidIDAndUserUuidID(documentEntity.getUuidID(), user.getUuidID())) {
						continue; // Pomijamy tworzenie połączenia, jeśli już istnieje
				}

				UserDocumentConnection connection = UserDocumentConnection.builder()
								.document(documentEntity)
								.user(user)
								.build();
				connections.add(connection);

				// Przypisanie połączenia użytkownikowi
				if (user.getUserDocumentConnections() == null) user.setUserDocumentConnections(new ArrayList<>());
				user.getUserDocumentConnections().add(connection);

				// Przypisanie połączenia dokumentowi
				if (documentEntity.getUserDocumentConnections() == null)
						documentEntity.setUserDocumentConnections(new ArrayList<>());

				documentEntity.getUserDocumentConnections().add(connection);
		}

		// Zapis wszystkich połączeń w bazie danych
		userDocumentConnectionRepository.saveAll(connections);

		// Wysyłanie powiadomień do użytkowników na podstawie ich preferencji
		eligibleUsers.forEach(user -> {
			if (user.getNotificationTypes() != null) {
				user.getNotificationTypes().forEach(notificationType -> {
					switch (notificationType.getType()) {
						case EMAIL:
							mailService
							.sendNotificationMail(
										"Nowy dokument",
										"Nowy dokument został oddany: " + documentEntity.getDocumentName(),
										user.getEmail()
							);
							break;
						case SMS:
							smsService.sendSms(
											"Nowy dokument został oddany: " + documentEntity.getDocumentName(),
											user.getPhoneNumber()
							);
							break;
						default:
							throw new IllegalStateException("Unexpected value: " + notificationType.getType());
					}
			});
		}
		});

		// Zwracanie odpowiedzi z informacjami o nowo załadowanym dokumencie
		return DocumentResponse.builder()
						.documentName(documentEntity.getDocumentName())
						.documentType(documentEntity.getDocumentType())
						.createdAt(documentEntity.getCreatedAt())
						.documentExtension(documentEntity.getDocumentExtension())
						.build();
}
\end{lstlisting}

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Metoda usuwania dokumetów i konretnych połaczeń z dokumentami w klasie \texttt{DocumentServiceImp}]
 @Override
    @Transactional
    public String deleteDocument(UUID documentId, UUID userId, Boolean deleteCompletely) throws DocumentNotFoundException, UserNotFoundException, IllegalArgumentException {

        Document document = documentRepository.findById(documentId)
                .orElseThrow(() -> new DocumentNotFoundException("Document id: " + documentId + " not found"));

        if (deleteCompletely) {

            documentRepository.delete(document);
            return "Document id: " + documentId + " deleted successfully for all users";

        } else {

            // Usuwanie tylko połączenia użytkownika z dokumentem
            User user = userRepository.findById(userId)
                    .orElseThrow(() -> new UserNotFoundException("User id: " + userId + " not found"));

            UserDocumentConnection connection = userDocumentConnectionRepository
                    .findByDocumentUuidIDAndUserUuidID(documentId, userId)
                    .orElseThrow(() -> new IllegalArgumentException("Connection not found"));

            // Inicjalizujemy listy, jeśli są nullem, aby uniknąć NullPointerException
            if (user.getUserDocumentConnections() == null) user.setUserDocumentConnections(new ArrayList<>());
            if (document.getUserDocumentConnections() == null) document.setUserDocumentConnections(new ArrayList<>());

            // Usunięcie połączenia
            user.getUserDocumentConnections().remove(connection);
            document.getUserDocumentConnections().remove(connection);

            userDocumentConnectionRepository.delete(connection);

            mailService.sendNotificationMail(
                    "Dokument odłączony",
                    "Dokument został odłaczony od twojego konta: " + document.getDocumentName(),
                    user.getEmail()
            );

            smsService.sendSms(
                    "Dokument został odłaczony od twojego konta: " + document.getDocumentName(),
                    user.getPhoneNumber()
            );

            return "Document id: " + documentId + " disconnected successfully for user id: " + userId;
        }
    }
}
\end{lstlisting}


\subsection{Istniejące rozwiązania do ochrony i przepływu dokumentów}

Współczesne systemy zarządzania dokumentami (DMS) oferują szereg funkcji zapewniających bezpieczeństwo oraz efektywny przepływ dokumentów w organizacjach. Poniżej przedstawiono kluczowe mechanizmy i narzędzia stosowane w tym zakresie:

\begin{itemize}
	\item \textbf{Kontrola dostępu ACL} -- umożliwia definiowanie uprawnień dla użytkowników lub grup, określając, kto może przeglądać, edytować czy usuwać konkretne dokumenty. Dzięki temu tylko upoważnione osoby mają dostęp do wrażliwych informacji~\cite{acl, acl_2}.
	
	\item \textbf{Szyfrowanie danych} -- zapewnia ochronę dokumentów podczas ich przechowywania oraz transmisji, uniemożliwiając nieautoryzowanym podmiotom odczytanie zawartości bez odpowiednich kluczy deszyfrujących~\cite{szyrowanie_danych}.

	\item \textbf{Śledzenie wersji (Version Control)} -- pozwala na monitorowanie zmian w dokumentach, zachowując historię modyfikacji. Umożliwia to powrót do wcześniejszych wersji oraz identyfikację autorów poszczególnych zmian~\cite{kotntrola_wersji}. 
	
	\item \textbf{Elektroniczny obieg dokumentów (Workflow Automation)} -- automatyzuje procesy związane z przepływem dokumentów między pracownikami i działami, eliminując potrzebę ręcznego przekazywania dokumentów i przyspieszając procesy decyzyjne~\cite{workflow_utomation}.

	\item \textbf{Integracja z innymi systemami} -- nowoczesne DMS często integrują się z innymi narzędziami biznesowymi, takimi jak systemy ERP czy CRM, co umożliwia spójny przepływ informacji w całej organizacji~\cite{dms}. 

	\item \textbf{Zgodność z regulacjami prawnymi} -- systemy te są projektowane tak, aby spełniać wymogi prawne dotyczące przechowywania i ochrony danych, co jest kluczowe w kontekście RODO czy innych regulacji branżowych~\cite{rodo_dokumenty}.
	
	\item \textbf{Guardian w Pythonie} -- w środowiskach programistycznych opartych na Pythonie popularnym rozwiązaniem do zarządzania uprawnieniami jest biblioteka \texttt{Guardian}. Umożliwia ona implementację bardziej zaawansowanych mechanizmów kontroli dostępu, takich jak przypisywanie uprawnień na poziomie obiektów (\emph{object-level permissions}). Dzięki \texttt{Guardian} każdemu dokumentowi można przypisać indywidualne reguły dostępu, zapewniając wysoki poziom bezpieczeństwa w aplikacjach. Przykładowo, dostęp do dokumentu może być ograniczony do konkretnego użytkownika lub grupy użytkowników, z precyzyjną kontrolą nad operacjami, które mogą oni wykonywać (np. odczyt, edycja, usunięcie)~\cite{django_guardian}.  
	
\end{itemize}

Wybór odpowiedniego systemu zarządzania dokumentami powinien uwzględniać specyficzne potrzeby organizacji, jej strukturę oraz obowiązujące regulacje prawne. Implementacja takich rozwiązań przyczynia się do zwiększenia efektywności operacyjnej oraz podniesienia poziomu bezpieczeństwa informacji.

\section{Zarządzie zgłoszeniami problemów}

System zarządzania zgłoszeniami problemów w prototypie „Harmony Home Net” umożliwia użytkownikom zgłaszanie różnego rodzaju problemów związanych z ich mieszkaniem. Obecna implementacja zapewnia podstawowe funkcjonalności dodawania zgłoszeń, zarządzania ich statusem oraz powiązania ich z odpowiednimi użytkownikami i mieszkaniami.

\subsection{Opis encji \texttt{ProblemReport}}

Encja \texttt{ProblemReport} jest centralnym elementem zarządzania zgłoszeniami. Poniżej przedstawiono jej definicję oraz szczegółowy opis.

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Definicja encji \texttt{ProblemReport}]
@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Entity
@Table(name = "Problem_reports", indexes = {
    @Index(name = "idx_problem_filing_date", columnList = "End_date"),
    @Index(name = "idx_problem_status", columnList = "status"),
    @Index(name = "idx_problem_user_id", columnList = "user_id"),
    @Index(name = "idx_problem_apartment_id", columnList = "apartment_id"),
    @Index(name = "idx_problem_create_at", columnList = "Created_at")
})
public class ProblemReport {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID")
    private Long id;

    @NotNull
    @Enumerated(EnumType.STRING)
    @Column(name = "Status", nullable = false)
    private ReportStatus reportStatus;

    @NotEmpty
    @Size(max = 1000)
    @Column(name = "Note", length = 1000, nullable = false)
    private String note;

    @NotNull
    @Enumerated(EnumType.STRING)
    @Column(name = "Category", nullable = false)
    private Category category;

    @Column(name = "End_date")
    private Instant endDate;

    @CreationTimestamp
    @Column(name = "Created_at", nullable = false)
    private Instant createdAt;

    @ManyToOne
    @JoinColumn(name = "user_id", referencedColumnName = "UUID_id")
    @JsonBackReference
    private User user;

    @ManyToOne
    @JoinColumn(name = "apartment_id", referencedColumnName = "UUID_id")
    @JsonBackReference
    private Apartment apartment;
}
\end{lstlisting}

Opis pól encji:
\begin{itemize}
    \item \textbf{\texttt{id}} -- Unikalny identyfikator zgłoszenia.
    \item \textbf{\texttt{reportStatus}} -- Status zgłoszenia (\texttt{OPEN}, \texttt{IN\_PROGRESS}, \texttt{DONE}).
    \item \textbf{\texttt{note}} -- Szczegóły zgłoszenia, opisujące problem (maksymalnie 1000 znaków).
    \item \textbf{\texttt{category}} -- Kategoria zgłoszenia (\texttt{GENERAL}, \texttt{TECHNICAL}, \texttt{FINANCIAL}, \texttt{OTHER}).
    \item \textbf{\texttt{endDate}} -- Data zakończenia zgłoszenia.
    \item \textbf{\texttt{createdAt}} -- Data utworzenia zgłoszenia.
    \item \textbf{\texttt{user}} -- Powiązanie zgłoszenia z użytkownikiem, który je złożył.
    \item \textbf{\texttt{apartment}} -- Powiązanie zgłoszenia z mieszkaniem, którego dotyczy.
\end{itemize}

\subsection{Proces zgłaszania i zarządzania zgłoszeniami}

Zgłaszanie problemów przez właściciela:
\begin{itemize}
    \item Użytkownik, będący właścicielem mieszkania, może zgłosić problem dotyczący konkretnego mieszkania. 
    \item Zgłoszenie jest tworzone z określeniem kategorii, opisu problemu oraz inicjalnym statusem (\texttt{OPEN}).
		\item Właściel/właściele danego mieszkania maja w czasie rzeczywistym podgąl do zgłsznie do danego mieszkania oraz dostaja powiadomienia jeśli dojdzie  do jakieś zmiany w zgłoszeniu.
\end{itemize}

Zarządzanie zgłoszeniami przez pracownika:
\begin{itemize}
    \item Pracownicy mogą edytować zgłoszenia, zmieniając ich status (\texttt{IN\_PROGRESS}, \texttt{DONE}) oraz wprowadzając dodatkowe informacje w notatkach.
    \item Obecna implementacja umożliwia jedynie manualne zarządzanie statusem i opisem zgłoszeń.
\end{itemize}

Utrzymanie zgłoszeń przy zmianie właściciela mieszkania:
\begin{itemize}
    \item W przypadku zmiany właściciela mieszkania, zgłoszenia pozostają w systemie i są automatycznie przypisywane nowym właścicielom.
    \item Dzięki temu historia problemów związanych z mieszkaniem pozostaje dostępna dla nowych właścicieli.
\end{itemize}


\subsection{Funkcje serwisu \texttt{ProblemReportServiceImp}}

Serwis \texttt{ProblemReportServiceImp} obsługuje kluczowe operacje związane z zarządzaniem zgłoszeniami problemów. Oto szczegółowy opis funkcji wraz z ich implementacją:

Tworzenie zgłoszenia problemu.

Funkcja \texttt{createProblemReport} umożliwia dodanie nowego zgłoszenia problemu przez użytkownika. Proces obejmuje:
\begin{enumerate}
    \item Walidację istnienia mieszkania na podstawie sygnatury (\texttt{apartmentSignature}).
    \item Sprawdzenie, czy użytkownik jest powiązany z danym mieszkaniem na podstawie tabeli historii posiadania (\texttt{PossessionHistory}).
    \item Utworzenie nowego zgłoszenia problemu z przypisaniem go do odpowiedniego użytkownika i mieszkania.
    \item Zapis zgłoszenia w repozytorium \texttt{ProblemReportRepository}.
\end{enumerate}

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Tworzenie zgłoszenia problemu.]
@Override
@Transactional
public ProblemReportResponse createProblemReport(ProblemReportRequest problemReportRequest) throws UserNotFoundException, ApartmentNotFoundException {

        String apartmentSignature = problemReportRequest.getApartmentSignature();
        Apartment apartment = apartmentsRepository.findByApartmentSignature(apartmentSignature)
                .orElseThrow(() -> new ApartmentNotFoundException("Apartment not found with id: " + apartmentSignature));

        UUID userId = problemReportRequest.getUserId();

        if (!possessionHistoryRepository.existsByUserUuidIDAndApartmentUuidID(userId, apartment.getUuidID())) {
            throw new UserNotFoundException("User with id: " + userId + " does not have access to apartment with signature: " + apartmentSignature);
        }

        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("User not found with id: " + userId));

        ProblemReport newProblemReport = ProblemReport.builder()
                .note(problemReportRequest.getNote())
                .reportStatus(problemReportRequest.getReportStatus())
                .category(problemReportRequest.getCategory())
                .user(user)
                .apartment(apartment)
                .build();


        if (user.getProblemReports() == null) user.setProblemReports(new ArrayList<>());
        user.getProblemReports().add(newProblemReport);

        if (apartment.getProblemReports() == null) apartment.setProblemReports(new ArrayList<>());
        apartment.getProblemReports().add(newProblemReport);

        ProblemReport saved = problemReportRepository.save(newProblemReport);
        userRepository.save(user);
        apartmentsRepository.save(apartment);

        return ProblemReportResponse.builder()
                .id(saved.getId())
                .note(saved.getNote())
                .reportStatus(saved.getReportStatus())
                .category(saved.getCategory())
                .userName(user.getFirstName() + " " + user.getLastName())
                .apartmentAddress(apartment.getAddress())
                .build();
    }
\end{lstlisting}

\textbf{Aktualizacja zgłoszenia problemu} -- funkcja \texttt{updateProblemReport} pozwala na aktualizację statusu zgłoszenia oraz jego szczegółów. Jeśli zgłoszenie zostanie oznaczone jako zakończone (\texttt{DONE}), ustawiana jest również data zakończenia.

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Aktualizacja zgłoszenia problemu.]
@Override
public ProblemReportResponse updateProblemReport(Long problemReportId, ProblemReportRequest problemReportRequest) throws ProblemReportNotFoundException {

        ProblemReport problemReportToUpdate = problemReportRepository.findById(problemReportId)
             .orElseThrow(() -> new ProblemReportNotFoundException("Problem report not found with id: " + problemReportId));

        problemReportToUpdate.setNote(problemReportRequest.getNote() != null ? problemReportRequest.getNote() : problemReportToUpdate.getNote());
        problemReportToUpdate.setReportStatus(problemReportRequest.getReportStatus() != null ? problemReportRequest.getReportStatus() : problemReportToUpdate.getReportStatus());
        problemReportToUpdate.setCategory(problemReportRequest.getCategory() != null ? problemReportRequest.getCategory() : problemReportToUpdate.getCategory());

        if (ReportStatus.DONE.equals(problemReportRequest.getReportStatus()))
            problemReportToUpdate.setEndDate(Instant.now());

        User user = problemReportToUpdate.getUser();

        if (user.getNotificationTypes() != null){
            user.getNotificationTypes().forEach(notificationType -> {
                switch (notificationType.getType()) {
                    case EMAIL:
                        switch (problemReportRequest.getReportStatus()) {
                            case DONE -> mailService.sendNotificationMail("Problem report done", "Your problem report has been done", user.getEmail());
                            case IN_PROGRESS -> mailService.sendNotificationMail("Problem report in progress", "Your problem report is in progress", user.getEmail());
                            case OPEN -> mailService.sendNotificationMail("Problem report open", "Your problem report is open", user.getEmail());
                        }
                        break;
                    case SMS:
                        switch (problemReportRequest.getReportStatus()) {
                            case DONE -> smsService.sendSms("Your problem report has been done", user.getPhoneNumber());
                            case IN_PROGRESS -> smsService.sendSms("Your problem report is in progress", user.getPhoneNumber());
                            case OPEN -> smsService.sendSms("Your problem report is open", user.getPhoneNumber());
                        }
                        break;

                    default:
                        throw new IllegalStateException("Unexpected value: " + notificationType.getType());
                }
            });
        }


        ProblemReport updated = problemReportRepository.save(problemReportToUpdate);

        return ProblemReportResponse.builder()
                .id(updated.getId())
                .note(updated.getNote())
                .reportStatus(updated.getReportStatus())
                .category(updated.getCategory())
                .userName(updated.getUser().getFirstName() + " " + updated.getUser().getLastName())
                .apartmentAddress(updated.getApartment().getAddress())
                .endDate(updated.getEndDate())
                .build();

    }
\end{lstlisting}

\textbf{Powiadamianie użytkowników o zmianach statusu zgłoszeń} -- metoda \texttt{updateProblemReport} zawiera również logikę wysyłania powiadomień do użytkowników za pomocą e-maili lub wiadomości SMS o zmianie statusu zgłoszenia. Dzięki temu użytkownicy są na bieżąco informowani o postępach w realizacji zgłoszenia.

\subsection{Przyszły rozwój systemu}
Obecny system zarządzania zgłoszeniami jest prototypem, a jego funkcjonalności mogą zostać rozszerzone w przyszłości:
\begin{itemize}
    \item Wprowadzenie integracji z systemami zarządzania usługami naprawczymi, aby automatycznie przekazywać zgłoszenia do odpowiednich serwisów zewnętrznych.
    \item Rozbudowa struktury zgłoszeń o możliwość przypisywania zgłoszeń do konkretnych pracowników odpowiedzialnych za ich realizację.
    \item Dodanie możliwości załączania zdjęć i plików do zgłoszeń w celu dokładniejszego dokumentowania problemów.
\end{itemize}


\section{Zarządzanie ogłoszeniami}

System zarządzania ogłoszeniami w prototypie „Harmony Home Net” umożliwia administratorom i pracownikom publikowanie ogłoszeń oraz przypisywanie ich do konkretnych mieszkań. Mechanizm został zaprojektowany w sposób uproszczony, aby zaspokoić podstawowe potrzeby informacyjne użytkowników systemu.

\subsection{Struktura danych}

Ogłoszenia w systemie są reprezentowane przez encję \texttt{Announcement}, która przechowuje podstawowe informacje, takie jak tytuł, treść, czas utworzenia i aktualizacji oraz powiązanie z użytkownikiem odpowiedzialnym za dodanie ogłoszenia. Relacje z właścielami są zarządzane za pomocą tabeli pośredniczącej \texttt{AnnouncementApartment}. Poniżej przedstawiono kod implementacji encji:

\textbf{Encja \texttt{Announcement}}
\begin{lstlisting}[language=Java, style=JavaStyle, caption=Encja \texttt{Announcement}]
@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Entity
@Table(name = "Announcements", indexes = {
        @Index(name = "idx_announcement_user_id", columnList = "user_id"),
        @Index(name = "idx_announcement_created_at", columnList = "created_at"),
        @Index(name = "idx_announcement_updated_at", columnList = "updated_at")
})
public class Announcement {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID")
    private Long id;

    @NotEmpty
    @Size(max = 50)
    @Column(name = "Title", nullable = false, length = 50)
    private String title;

    @NotEmpty
    @Size(max = 1000)
    @Column(name = "Content", nullable = false, length = 1000)
    private String content;

    @CreationTimestamp
    @Column(name = "Created_at", nullable = false)
    private Instant createdAt;

    @UpdateTimestamp
    @Column(name = "Updated_at")
    private Instant updatedAt;

    @ManyToOne
    @JoinColumn(name = "user_id", referencedColumnName = "UUID_id")
    @JsonBackReference
    private User user;

    @OneToMany(mappedBy = "announcement", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    @JsonManagedReference
    private List<AnnouncementApartment> announcementApartments;

}
\end{lstlisting}

\textbf{Tabela pośrednicząca \texttt{AnnouncementApartment}} -- tabela \texttt{AnnouncementApartment} zarządza relacjami między ogłoszeniami a mieszkaniami, umożliwiając przypisywanie i odłączanie ogłoszeń od wybranych nieruchomości. Przykładowa implementacja poniżej:

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Encja \texttt{AnnouncementApartment}]
@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Entity
@Table(name = "Announcement_apartments",
        indexes = {
                @Index(name = "idx_announcement_apartment", columnList = "apartment_id"),
                @Index(name = "idx_announcement", columnList = "announcement_id")
        },
        uniqueConstraints = {
                @UniqueConstraint(columnNames = {"apartment_id", "announcement_id"})
        })
public class AnnouncementApartment {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID")
    private Long id;

    @ManyToOne
    @JoinColumn(name = "apartment_id", referencedColumnName = "UUID_id")
    @JsonBackReference
    private Apartment apartment;

    @ManyToOne
    @JoinColumn(name = "announcement_id", referencedColumnName = "ID")
    @JsonBackReference
    private Announcement announcement;

    public void removeAssociation() {
        if (this.announcement != null) {
            this.announcement.getAnnouncementApartments().remove(this);
            this.announcement = null;
        }
        if (this.apartment != null) {
            this.apartment.getAnnouncementApartments().remove(this);
            this.apartment = null;
        }
    }
}
\end{lstlisting}

\subsection{Funkcjonalności systemu ogłoszeń}

\textbf{Dodawanie ogłoszeń} -- ogłoszenia mogą być dodawane przez administratorów i pracowników za pomocą metody \texttt{createAnnouncement}. W procesie tym podawane są informacje, takie jak tytuł, treść oraz identyfikator użytkownika odpowiedzialnego za utworzenie ogłoszenia. Poniżej przedstawiono implementację:

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Dodawanie ogłoszenia.]
@Override
public AnnouncementResponse createAnnouncement(AnnouncementRequest announcementRequest) 
        throws UserNotFoundException {

    UUID userId = announcementRequest.getUserId();
    User user = userRepository.findById(userId)
            .orElseThrow(() -> new UserNotFoundException("User: " + userId + " not found"));

    Announcement announcement = Announcement.builder()
            .title(announcementRequest.getTitle())
            .content(announcementRequest.getContent())
            .user(user)
            .build();

    Announcement saved = announcementRepository.save(announcement);
    return AnnouncementResponse.builder()
            .id(saved.getId())
            .title(saved.getTitle())
            .content(saved.getContent())
            .createdAt(saved.getCreatedAt())
            .updatedAt(saved.getUpdatedAt())
            .build();
}
\end{lstlisting}

\textbf{Przypisywanie ogłoszeń do mieszkań} -- administratorzy i pracownicy mogą przypisywać ogłoszenia do konkretnych mieszkań za pomocą metody \texttt{linkAnnouncementsToApartments}. W procesie tym:
\begin{enumerate}
    \item Pobierane są identyfikatory mieszkań.
    \item Tworzone są nowe powiązania między ogłoszeniem a mieszkaniami.
    \item Powiadomienia o nowym ogłoszeniu są wysyłane do właścicieli mieszkań.
\end{enumerate}

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Przypisywanie ogłoszeń do mieszkań.]
@Override
@Transactional
public String linkAnnouncementsToApartments(Long announcementId, List<String> apartmentSignatures) 
        throws AnnouncementNotFoundException, ApartmentNotFoundException {

    Announcement announcement = announcementRepository.findById(announcementId)
            .orElseThrow(() -> new AnnouncementNotFoundException("Announcement: " + announcementId + " not found"));

    List<AnnouncementApartment> newAnnouncementApartments = apartmentSignatures.stream()
            .map(apartmentSignature -> apartmentsRepository.findByApartmentSignature(apartmentSignature)
                    .orElseThrow(() -> new ApartmentNotFoundException("Apartment: " + apartmentSignature + " not found")))
            .map(apartment -> AnnouncementApartment.builder()
                    .announcement(announcement)
                    .apartment(apartment)
                    .build())
            .toList();

    announcementApartmentRepository.saveAll(newAnnouncementApartments);
    return "Linked " + newAnnouncementApartments.size() + " apartments to announcement: " + announcementId;
}
\end{lstlisting}

\textbf{Odłączanie ogłoszeń od mieszkań} -- odłączanie ogłoszeń od mieszkań odbywa się za pomocą metody \texttt{unlinkAnnouncementsFromApartments}. Proces ten usuwa powiązania między wskazanymi mieszkaniami a ogłoszeniem.

\subsection{Możliwości rozbudowy systemu zarządzania ogłoszeniami}

W obecnej formie system zarządzania ogłoszeniami w „Harmony Home Net” został zaprojektowany jako prototypowy, z podstawowym zestawem funkcji umożliwiających publikację i zarządzanie ogłoszeniami. W przyszłości można rozważyć rozszerzenie funkcjonalności systemu o poniższe elementy:

\begin{enumerate}
    \item \textbf{Rozbudowa uprawnień dostępu}
    \begin{itemize}
        \item Dodanie bardziej precyzyjnych mechanizmów kontroli dostępu, takich jak przypisywanie ról z różnymi poziomami uprawnień do ogłoszeń (np. możliwość przeglądania, edycji, usuwania).
        \item Implementacja ACL w celu definiowania indywidualnych uprawnień na poziomie ogłoszeń, mieszkań czy użytkowników~\cite{acl, acl_2}.
    \end{itemize}

    \item \textbf{Obsługa zaawansowanych powiadomień}
    \begin{itemize}
        \item Wprowadzenie dynamicznych powiadomień, takich jak notyfikacje push, integracje z aplikacjami mobilnymi czy webhooki do zewnętrznych systemów.
        \item Możliwość tworzenia szablonów powiadomień z dostosowywaniem treści do odbiorcy (np. inny komunikat dla administratorów, a inny dla właścieli).
    \end{itemize}

    \item \textbf{Personalizacja ogłoszeń}
    \begin{itemize}
        \item Dodanie możliwości tworzenia ogłoszeń przypisanych do grup użytkowników (np. tylko do właścieli konkretnej dzielnicy lub piętra).
        \item Opcja filtrowania ogłoszeń na podstawie kategorii, priorytetu lub statusu (np. aktywne, archiwalne).
    \end{itemize}

    \item \textbf{Historia i wersjonowanie ogłoszeń}
    \begin{itemize}
        \item Wprowadzenie historii zmian ogłoszeń, która umożliwi śledzenie edycji tytułów lub treści wraz z informacjami o autorach.
        \item Możliwość powrotu do poprzednich wersji ogłoszeń w przypadku błędów lub pomyłek.
    \end{itemize}

    \item \textbf{Dodanie zaawansowanych kategorii i tagowania}
    \begin{itemize}
        \item Wprowadzenie kategorii ogłoszeń (np. techniczne, administracyjne, ogólne) oraz tagów umożliwiających lepsze wyszukiwanie i organizację treści.
        \item Dynamiczne filtry w interfejsie użytkownika do łatwego przeszukiwania ogłoszeń na podstawie kategorii, tagów lub dat.
    \end{itemize}

    \item \textbf{Integracja z systemami zewnętrznymi}
    \begin{itemize}
        \item Połączenie systemu ogłoszeń z aplikacjami mobilnymi lub zewnętrznymi systemami zarządzania nieruchomościami (np. platformy CRM/ERP).
        \item Dodanie API umożliwiającego zewnętrznym aplikacjom publikowanie ogłoszeń lub pobieranie ich w czasie rzeczywistym.
    \end{itemize}

    \item \textbf{Zaawansowana analiza i raportowanie}
    \begin{itemize}
        \item Tworzenie raportów na temat liczby opublikowanych ogłoszeń, ich zasięgu oraz aktywności użytkowników (np. ile osób otworzyło ogłoszenie).
        \item Możliwość analizy skuteczności powiadomień w zależności od użytego kanału (e-mail, SMS, push).
    \end{itemize}

    \item \textbf{Automatyzacja publikacji ogłoszeń}
    \begin{itemize}
        \item Wprowadzenie harmonogramów publikacji ogłoszeń, aby mogły być one automatycznie publikowane w określonym czasie.
        \item Opcja automatycznego archiwizowania ogłoszeń po upływie daty ważności.
    \end{itemize}

    \item \textbf{Dodanie systemu komentarzy i potwierdzeń}
    \begin{itemize}
        \item Możliwość dodawania komentarzy do ogłoszeń przez użytkowników w celu wyrażenia opinii lub zadania pytań.
        \item Funkcja potwierdzenia przeczytania ogłoszenia przez użytkowników, co ułatwi monitorowanie zasięgu informacji.
    \end{itemize}

    \item \textbf{Mechanizmy bezpieczeństwa i zgodności}
    \begin{itemize}
        \item Wprowadzenie logowania aktywności związanych z zarządzaniem ogłoszeniami w celu zapewnienia audytowalności.
        \item Zapewnienie zgodności z regulacjami prawnymi dotyczącymi ochrony danych, takimi jak RODO, w kontekście przechowywania i dystrybucji ogłoszeń.
    \end{itemize}
\end{enumerate}

Dzięki tym usprawnieniom system zarządzania ogłoszeniami w „Harmony Home Net” może ewoluować w bardziej zaawansowane narzędzie, które zwiększy efektywność komunikacji między pracownikami wspólnoty, a właścielami mieszkań, jednocześnie oferując większą elastyczność i bezpieczeństwo.


\section{Zarządzanie forum dla wspólnoty}

System forum w aplikacji „Harmony Home Net” został zaprojektowany w formie uproszczonej, z uwzględnieniem podstawowych potrzeb komunikacyjnych mieszkańców wspólnoty. Forum pozwala użytkownikom tworzyć tematy, dodawać posty oraz zarządzać ich treścią w ramach jasno określonych zasad i ograniczeń.

\subsection{Opis encji}
Forum składa się z dwóch głównych encji: \texttt{Topic} (temat) i \texttt{Post} (post), które są powiązane z użytkownikami (\texttt{User}).

\subsubsection{\texttt{Topic} -- Temat forum}
Encja \texttt{Topic} reprezentuje główny wątek dyskusyjny. Każdy temat zawiera następujące pola:
\begin{itemize}
    \item \textbf{UUID\_id} -- unikalny identyfikator tematu.
    \item \textbf{title} -- tytuł tematu, ograniczony do 50 znaków.
    \item \textbf{createdAt} -- data utworzenia tematu.
    \item \textbf{user} -- odniesienie do użytkownika, który stworzył temat.
    \item \textbf{posts} -- lista postów przypisanych do danego tematu.
\end{itemize}

Kod encji:
\begin{lstlisting}[language=Java, style=JavaStyle, caption=Encja \texttt{Topic}]
@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Entity
@Table(name = "Topics", indexes = {
        @Index(name = "idx_topic_created_at", columnList = "Created_at"),
        @Index(name = "idx_topic_users_id", columnList = "users_id")
})
public class Topic {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID uuidID;

    @NotEmpty
    @Size(max = 50)
    private String title;

    @CreationTimestamp
    private Instant createdAt;

    @ManyToOne
    private User user;

    @OneToMany(mappedBy = "topic", cascade = CascadeType.REMOVE, orphanRemoval = true)
    private List<Post> posts;
}
\end{lstlisting}

\subsubsection{\texttt{Post} -- Post na forum}
Encja \texttt{Post} reprezentuje pojedynczą wypowiedź w danym temacie. Każdy post zawiera następujące pola:
\begin{itemize}
    \item \textbf{UUID\_id} -- unikalny identyfikator posta.
    \item \textbf{content} -- treść posta, ograniczona do 1000 znaków.
    \item \textbf{createdAt} -- data utworzenia posta.
    \item \textbf{topic} -- odniesienie do tematu, w którym post został zamieszczony.
    \item \textbf{user} -- odniesienie do użytkownika, który zamieścił post.
\end{itemize}

Kod encji:
\begin{lstlisting}[language=Java, style=JavaStyle, caption=Encja \texttt{Post}]
@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Entity
@Table(name = "Posts", indexes = {
      @Index(name = "idx_post_created_at", columnList = "Created_at"),
      @Index(name = "idx_post_topic_id", columnList = "topic_id"),
      @Index(name = "idx_post_users_id", columnList = "users_id")
})
public class Post {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID uuidID;

    @NotEmpty
    @Size(max = 1000)
    private String content;

    @CreationTimestamp
    private Instant createdAt;

    @ManyToOne
    private Topic topic;

    @ManyToOne
    private User user;
}
\end{lstlisting}

\subsection{Obecna funkcjonalność systemu forum}
\begin{itemize}
    \item \textbf{Tworzenie tematów} -- każdy użytkownik może utworzyć nowy temat, który staje się dostępny dla wszystkich członków wspólnoty.
    \item \textbf{Dodawanie postów} -- użytkownicy mogą dodawać odpowiedzi (posty) w ramach wybranego tematu.
    \item \textbf{Zarządzanie postami i tematami} -- Posty i tematy nie mogą być edytowane, ale mogą być usuwane przez autora lub osoby z rolą pracowniczą.
    \item \textbf{Historia i trwałość danych} -- posty i tematy pozostają w systemie nawet po usunięciu użytkownika, a w interfejsie użytkownika przy autorze wyświetlana jest informacja, że użytkownik został usunięty.
    \item \textbf{Brak struktury drzewiastej} -- dyskusje w ramach tematów są liniowe, bez możliwości tworzenia wątków zagnieżdżonych.
\end{itemize}

\subsection{Możliwości rozbudowy systemu forum}
\begin{itemize}
    \item \textbf{Edycja postów i tematów} -- wprowadzenie funkcji edytowania istniejących postów i tematów, z zachowaniem historii zmian.
    \item \textbf{Prywatne wątki} -- możliwość tworzenia wątków dostępnych tylko dla wybranej grupy użytkowników (np. mieszkańców konkretnego mieszkania).
    \item \textbf{Powiadomienia} -- dynamiczne powiadamianie użytkowników o nowych postach lub tematach poprzez e-mail, SMS lub notyfikacje push.
    \item \textbf{Ocena treści} -- dodanie funkcji oceniania postów (np. poprzez system „Lubię to” lub głosy w górę/w dół).
    \item \textbf{Raportowanie treści} -- mechanizm zgłaszania nieodpowiednich treści do moderacji.
    \item \textbf{Tagowanie tematów} -- wprowadzenie tagów pozwalających na łatwiejsze wyszukiwanie i organizację wątków.
    \item \textbf{Integracja z innymi modułami} -- połączenie forum z modułem ogłoszeń lub zarządzania dokumentami, np. poprzez dodawanie linków do istotnych zasobów.
    \item \textbf{Statystyki} -- generowanie raportów na temat aktywności użytkowników na forum.
\end{itemize}

Rozbudowa forum może znacząco zwiększyć zaangażowanie włąścieli oraz poprawić komunikację w ramach wspólnoty, czyniąc system bardziej funkcjonalnym i wszechstronnym.

\section{Zarządzanie płatnościami}

System zarządzania płatnościami w prototypie „Harmony Home Net” został zaprojektowany w sposób uproszczony. Mechanizm umożliwia przypisywanie płatności do konkretnego mieszkania z pomocą sygnatury lokalu, z opcją dodawania szczegółowych komponentów płatności. Kluczowym elementem jest pole \texttt{Ready\_to\_Pay}, które pełni funkcję zabezpieczenia przed przedwczesnym udostępnieniem płatności do realizacji. Właściciel mieszkania ma dostęp do listy wszystkich przypisanych płatności, jednak możliwość ich wykonania (np. poprzez aktywny przycisk płatności) jest blokowana do momentu ustawienia pola \texttt{Ready\_to\_Pay} na \texttt{true}. Dzięki temu płatności nie mogą zostać zrealizowane przed ich odpowiednim przygotowaniem.

\subsection{Opis encji}

Encja \texttt{Payment} -- reprezentuje płatność przypisaną do konkretnego mieszkania. Oto kluczowe elementy:

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Kod encji \texttt{Payment}]
@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Entity
@Table(name = "Payments", indexes = {
        @Index(name = "idx_payment_apartment_id", columnList = "apartment_id"),
        @Index(name = "idx_payment_date", columnList = "Payment_date"),
})
public class Payment {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID uuidID;

    @NotEmpty
    private String description;

    @NotNull
    @Enumerated(EnumType.STRING)
    private PaymentStatus paymentStatus;

    @NotNull
    private Instant paymentDate;

    private Instant paymentTime;

    @DecimalMin(value = "0.0")
    private BigDecimal paymentAmount;

    @CreationTimestamp
    private Instant createdAt;

    private Boolean readyToPay;

    @ManyToOne
    @JoinColumn(name = "apartment_id", referencedColumnName = "UUID_id")
    private Apartment apartment;

    @OneToMany(mappedBy = "payment", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<PaymentComponent> paymentComponents;

    @PrePersist
    public void prePersist() {
        this.setPaymentDate(LocalDateTime.now().plusMonths(1).atZone(ZoneId.systemDefault()).toInstant());
        if (this.readyToPay == null) {
            this.readyToPay = false;
        }
    }
}
\end{lstlisting}

\begin{itemize}
    \item \textbf{\texttt{Ready\_to\_Pay}} -- pole definiujące, czy płatność jest gotowa do realizacji. Po stworzeniu płatność domyślnie ma wartość \texttt{false}.
    \item \textbf{Połączenie z mieszkaniem} -- każda płatność jest powiązana z encją \texttt{Apartment}, co pozwala na precyzyjne przypisanie jej do konkretnej nieruchomości.
    \item \textbf{\texttt{PrePersist}} -- mechanizm inicjalizujący datę płatności na jeden miesiąc od momentu jej utworzenia.
\end{itemize}

\textbf{Encja \texttt{PaymentComponent}} --- reprezentuje szczegółowy składnik płatności, który pozwala na rozbicie płatności na mniejsze części.

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Kod encji \texttt{PaymentComponent}]
@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Entity
@Table(name = "Payment_components", indexes = {
        @Index(name = "idx_paymentcomponent", columnList = "payment_id")
})
public class PaymentComponent {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotEmpty
    @Size(max = 50)
    private String componentType;

    @NotNull
    @DecimalMin(value = "0.0", inclusive = false)
    private BigDecimal unitPrice;

    @DecimalMin(value = "1.0")
    private BigDecimal specialMultiplier;

    @DecimalMin(value = "0.0", inclusive = false)
    private BigDecimal componentAmount;

    @NotNull
    private String unit;

    @CreationTimestamp
    private Instant createdAt;

    @UpdateTimestamp
    private Instant updatedAt;

    @ManyToOne
    @JoinColumn(name = "payment_id", referencedColumnName = "UUID_id")
    private Payment payment;
}
\end{lstlisting}

\begin{itemize}
    \item \textbf{\texttt{componentType}} -- typ komponentu płatności, np. \emph{energia elektryczna}, \emph{woda}.
    \item \textbf{\texttt{unitPrice}} -- cena jednostkowa za komponent.
    \item \textbf{\texttt{specialMultiplier}} -- specjalny mnożnik, pozwalający na modyfikację kosztów (np. rabaty, dodatkowe opłaty).
    \item \textbf{\texttt{componentAmount}} -- ilość jednostek związanych z danym komponentem.
\end{itemize}

\subsection{Proces dodawania płatności}

W prototypie systemu „Harmony Home Net” proces zarządzania płatnościami przebiega w trzech etapach. Obecnie jest to uproszczony mechanizm pełniący funkcję demonstracyjną (\emph{mock}). System nie posiada jeszcze zaawansowanych funkcjonalności, takich jak integracja z systemami płatności czy automatyzacja generowania komponentów. Niemniej jednak, poniższe etapy ilustrują podstawowy przepływ operacji:

\begin{enumerate}
    \item \textbf{Tworzenie płatności} -- Płatność jest tworzona przez administratora lub pracownika systemu. Na tym etapie płatność jest automatycznie przypisywana do mieszkania, a pole \texttt{Ready\_to\_Pay} zostaje ustawione na \texttt{false}. Dzięki temu płatność jest widoczna dla właściciela mieszkania, ale nie może być jeszcze zrealizowana. Poniżej znajduje się fragment kodu odpowiedzialny za ten proces:

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Fragment metody \texttt{createPayment}]
@Override
@Transactional
public PaymentResponse createPayment(PaymentRequest paymentRequest) throws ApartmentNotFoundException {
    Apartment apartment = apartmentsRepository.findByApartmentSignature(paymentRequest.getApartmentSignature())
            .orElseThrow(() -> new ApartmentNotFoundException("Apartment: " + paymentRequest.getApartmentSignature() + " not found"));

    Payment payment = Payment.builder()
            .paymentComponents(new ArrayList<>())
            .paymentStatus(PaymentStatus.UNPAID)
            .apartment(apartment)
            .description(paymentRequest.getDescription())
            .paymentAmount(BigDecimal.ZERO)
            .readyToPay(Boolean.FALSE)
            .build();

    Payment saved = paymentRepository.save(payment);
    apartmentsRepository.save(apartment);

    return PaymentResponse.builder()
            .paymentId(saved.getUuidID())
            .paymentStatus(saved.getPaymentStatus())
            .description(saved.getDescription())
            .readyToPay(saved.getReadyToPay())
            .build();
}
\end{lstlisting}

    \item \textbf{Dodawanie komponentów} -- Po stworzeniu płatności administrator lub pracownik dodaje komponenty płatności, takie jak opłaty za media. Każdy komponent jest dodawany osobno, a brak automatyzacji powoduje konieczność ręcznego wprowadzenia danych. Fragment kodu odpowiedzialny za dodawanie komponentów przedstawia poniższa metoda:

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Fragment metody \texttt{addPaymentComponent}]
@Override
@Transactional
public PaymentResponse addPaymentComponent(UUID paymentId, PaymentComponentRequest paymentComponentRequest) throws PaymentNotFoundException {
    Payment payment = paymentRepository.findById(paymentId)
            .orElseThrow(() -> new PaymentNotFoundException("Payment: " + paymentId + " not found"));

    PaymentComponent paymentComponent = PaymentComponent.builder()
            .payment(payment)
            .componentType(paymentComponentRequest.getComponentType())
            .componentAmount(paymentComponentRequest.getComponentAmount())
            .unitPrice(paymentComponentRequest.getUnitPrice())
            .specialMultiplier(paymentComponentRequest.getSpecialMultiplier())
            .unit(paymentComponentRequest.getUnit())
            .build();

    payment.getPaymentComponents().add(paymentComponent);
    recalculatePaymentAmount(payment);
    paymentRepository.save(payment);

    return getPaymentResponse(payment, paymentComponent);
}
\end{lstlisting}

    \item \textbf{Aktywacja płatności} -- Po dodaniu wszystkich komponentów płatności i upewnieniu się, że nie występują nieprawidłowości, pole \texttt{Ready\_to\_Pay} zostaje ustawione na \texttt{true}, co pozwala właścicielowi mieszkania na dokonanie płatności. Fragment kodu aktywującego płatność:

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Fragment metody \texttt{activatePayment}]
@Override
public String activatePayment(UUID paymentId, Boolean setActive) throws PaymentNotFoundException {
    Payment payment = paymentRepository.findById(paymentId)
            .orElseThrow(() -> new PaymentNotFoundException("Payment: " + paymentId + " not found"));

    payment.setReadyToPay(setActive);
    paymentRepository.save(payment);

    return "Payment: " + paymentId + " activated";
}
\end{lstlisting}
\end{enumerate}

\subsection{Realizacja płatności}

Realizacja płatności w aktualnym prototypie jest uproszczona i pełni funkcję \emph{mock}. Mechanizm polega na zmianie statusu płatności na \texttt{PAID} oraz ustawieniu czasu jej realizacji. Przykład kodu:

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Fragment metody \texttt{payPayment}]
@Override
public PaymentResponse payPayment(UUID paymentId, String account) throws PaymentNotFoundException {
    Payment payment = paymentRepository.findById(paymentId)
            .orElseThrow(() -> new PaymentNotFoundException("Payment: " + paymentId + " not found"));

    if (payment.getPaymentStatus() == PaymentStatus.PAID)
        throw new IllegalArgumentException("Payment: " + paymentId + " already paid");

    payment.setPaymentStatus(PaymentStatus.PAID);
    payment.setPaymentTime(Instant.now());

    Payment saved = paymentRepository.save(payment);

    bankingService.pay(payment.getPaymentAmount(), account);

    return PaymentResponse.builder()
            .paymentId(saved.getUuidID())
            .paymentStatus(saved.getPaymentStatus())
            .paymentTime(saved.getPaymentTime())
            .build();
}
\end{lstlisting}

W kolejnych etapach rozwoju systemu realizacja płatności zostanie rozbudowana i szczegółowo opisana w sekcji \textbf{Systemy zewnętrzne}. Planowane jest wprowadzenie integracji z zewnętrznymi dostawcami usług płatniczych, takimi jak Stripe, PayPal czy polski BLIK, co pozwoli na pełną automatyzację i bezpieczną obsługę transakcji.

\subsection{Harmonogram przypomnień o płatnościach}

W prototypie systemu „Harmony Home Net” za implementację automatycznych przypomnień o płatnościach odpowiada mechanizm harmonogramowania oparty na klasie \texttt{PaymentReminderScheduler}. Funkcjonalność ta obejmuje:

\begin{itemize}
    \item \textbf{Przypomnienia przed terminem płatności} -- użytkownicy otrzymują powiadomienia o nadchodzących płatnościach na dwa tygodnie oraz tydzień przed ich terminem. Mechanizm ten uruchamia się automatycznie w każdy poniedziałek o godzinie 12:00. Przykład fragmentu kodu obsługującego to przypomnienie:

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Przypomnienie o nadchodzących płatnościach]
@Scheduled(cron = "0 0 12 * * MON")
@Async
public void sendUpcomingPaymentReminders() {
    Instant twoWeeksBefore = Instant.now().plus(2, ChronoUnit.WEEKS);
    Instant oneWeekBefore = Instant.now().plus(1, ChronoUnit.WEEKS);

    List<Payment> upcomingPayments = paymentRepository.findByPaymentDateBetween(twoWeeksBefore, oneWeekBefore);

    for (Payment payment : upcomingPayments) {
        List<User> owners = payment.getApartment().getPossessionHistories().stream()
                .map(PossessionHistory::getUser)
                .toList();

        owners.forEach(owner -> {
            String message = "Przypomnienie: Twoja płatność za " + payment.getDescription() +
                    " jest wymagana do " + payment.getPaymentDate() + ".";
            sendNotification(owner.getEmail(), owner.getPhoneNumber(), message);
        });
    }
}
\end{lstlisting}

    \item \textbf{Przypomnienia o zaległych płatnościach} -- jeśli płatność nie zostanie zrealizowana w terminie, użytkownicy otrzymują przypomnienia co dwa dni. Ten mechanizm działa automatycznie i przypomina o konieczności uregulowania zaległości. Przykład fragmentu kodu odpowiedzialnego za przypomnienia po terminie:

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Przypomnienie o zaległych płatnościach]
@Scheduled(cron = "0 0 12 */2 * ?")
@Async
public void sendOverduePaymentReminders() {
    Instant today = Instant.now();

    List<Payment> overduePayments = paymentRepository.findByDueDateBeforeAndIsPaidFalse(today);

    for (Payment payment : overduePayments) {
        List<User> owners = payment.getApartment().getPossessionHistories().stream()
                .map(PossessionHistory::getUser)
                .toList();

        owners.forEach(owner -> {
            String message = "Przypomnienie o zaległej płatności: Twoja płatność za " + payment.getDescription() +
                    " była wymagana do " + payment.getPaymentDate() + ". Prosimy o dokonanie płatności jak najszybciej.";
            sendNotification(owner.getEmail(), owner.getPhoneNumber(), message);
        });
    }
}
\end{lstlisting}
\end{itemize}

\textbf{Powiadomienia} są wysyłane za pomocą e-maila lub SMS-a w zależności od preferencji użytkownika. Mechanizm ten bazuje na konfiguracji przechowywanej w tabeli z typami powiadomień (\texttt{NotificationType}).

Przykład metody wysyłającej powiadomienia:
\begin{lstlisting}[language=Java, style=JavaStyle, caption=Wysyłanie powiadomień]
private void sendNotification(String email, String phoneNumber, String message) {
    List<NotificationType> notificationTypes = notificationTypeRepository.findByUserEmail(email);

    if (notificationTypes.contains(Notification.EMAIL)) {
        mailService.sendNotificationMail("Payment Reminder", message, email);
    }
    if (notificationTypes.contains(Notification.SMS)) {
        smsService.sendSms(phoneNumber, message);
    }
}
\end{lstlisting}

Harmonogram przypomnień pozwala na regularne powiadamianie użytkowników o statusie ich płatności, minimalizując ryzyko opóźnień. W przyszłości funkcjonalność ta może zostać rozwinięta o bardziej zaawansowane metody planowania i integrację z dodatkowymi kanałami komunikacji, co zostanie szczegółowo opisane w sekcji „Systemy zewnętrzne”.

\subsection{Profesjonalne podejście do zarządzania płatnościami}

W pełnowymiarowych systemach płatności procesy te są znacznie bardziej złożone i obejmują:
\begin{itemize}
    \item \textbf{Automatyzację} -- generowanie komponentów płatności na podstawie danych historycznych, zapisów w umowach i prognoz zużycia, co eliminuje konieczność ręcznego wprowadzania danych.
    \item \textbf{Przewidywanie kosztów} -- wykorzystanie zaawansowanych modeli analizy danych do prognozowania przyszłych kosztów, co pozwala użytkownikom na lepsze planowanie budżetu.
    \item \textbf{Integrację z systemami płatności} -- obsługę popularnych dostawców, takich jak Stripe, PayPal czy polski BLIK, umożliwiając realizację transakcji bezpośrednio z poziomu systemu.
    \item \textbf{Natychmiastową realizację płatności} -- synchronizację transakcji z systemami księgowymi w czasie rzeczywistym, zapewniając aktualność danych finansowych.
    \item \textbf{Raportowanie} -- generowanie szczegółowych raportów dla właścicieli mieszkań i administratorów, umożliwiających monitorowanie statusu płatności i szczegółów transakcji.
\end{itemize}

\subsection{Diagramy BPMN}

\textbf{Diagramy BPMN} -- to standardowe narzędzie do modelowania procesów biznesowych, które umożliwia graficzne przedstawienie przepływu operacji~\cite{BPMN_wiki, BPMN_spec}. Są one używane do:
\begin{itemize}
    \item Definiowania ról (\emph{swimlanes}), takich jak użytkownik, administrator czy zewnętrzny dostawca usług płatniczych.
    \item Opisu zdarzeń początkowych, końcowych i pośrednich, które inicjują lub zmieniają bieg procesu.
    \item Modelowania decyzji i reguł biznesowych za pomocą bramek (\emph{gateways}), które określają różne ścieżki przepływu procesu.
    \item Przedstawienia czynności (\emph{tasks}) wykonywanych przez system lub użytkowników.
\end{itemize}

Dzięki BPMN można optymalizować procesy, identyfikować potencjalne punkty ryzyka oraz planować automatyzację i integrację z innymi systemami.

Przykładowy diagram BPMN dla procesu zarządzania płatnościami mógłby zawierać~\cite{BPMN_camunda}:
\begin{itemize}
    \item Generowanie płatności automatycznie na podstawie danych z systemu zarządzania nieruchomościami.
    \item Weryfikację poprawności komponentów płatności przez administratora.
    \item Przekazanie płatności do systemu zewnętrznego i odbiór potwierdzenia realizacji.
    \item Notyfikacje dla właścicieli mieszkań o statusie płatności.
\end{itemize}

Diagramy BPMN wspierają zarówno techniczne, jak i biznesowe aspekty zarządzania procesami, umożliwiając transparentność oraz łatwiejszą komunikację między zespołami technicznymi i biznesowymi.

\section{Zarządzanie głosowaniami}

System głosowań w prototypie „Harmony Home Net” umożliwia organizację głosowań nad ważnymi decyzjami dla wspólnoty mieszkaniowej. 

\subsection{Obecny stan implementacji}

W aktualnym prototypie system obsługuje głosowania na poziomie administracyjnym. Proces obejmuje tworzenie głosowania, przesyłanie dokumentu nad którym głosowanie się odbywa, oraz określenie dwóch kluczowych parametrów:
\begin{itemize}
    \item \textbf{Kworum} -- minimalna liczba oddanych głosów, aby głosowanie było ważne. Przykładowo, przy 100 mieszkaniach, ustalenie kworum na 60 oznacza, że co najmniej 60 mieszkań musi oddać głos.
    \item \textbf{Minimalny próg procentowy} -- suma udziałów procentowych mieszkań głosujących \texttt{FOR}, która musi zostać osiągnięta. Udziały te wynikają z powierzchni mieszkań w stosunku do całkowitej powierzchni wspólnoty.
\end{itemize}

Proces tworzenia głosowania jest w pełni funkcjonalny po stronie administracyjnej. Dokument głosowania jest przechowywany jako załącznik, a wynik pozytywny skutkuje zapisaniem głosowania do tabeli \texttt{Documents}, gdzie jest dostępny jako archiwum dla wszystkich użytkowników.

\textbf{Kluczowe aspekty techniczne}

1. \textbf{Głosowanie w przypadku współwłasności mieszkań} -- jeżeli mieszkanie ma kilku właścicieli, system akceptuje głos pierwszego z nich, który odda głos.
2. \textbf{Przypomnienia o głosowaniach} -- mechanizm harmonogramowania przypomina użytkownikom o aktywnych głosowaniach oraz informuje o ich wynikach.

\subsection{Proces głosowania}

\textbf{Tworzenie głosowania} odbywa się przy użyciu metody serwisowej \texttt{createPoll}, która przyjmuje nazwę głosowania, treść, wymagane parametry (kworum, próg procentowy) oraz plik dokumentu. Fragment kodu:

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Fragment metody \texttt{createPoll}]
@Override
@Transactional
public PollResponse createPoll(PollRequest pollRequest, UUID employeeId, MultipartFile file) throws UserNotFoundException, IOException {
    User user = userRepository.findById(employeeId)
            .orElseThrow(() -> new UserNotFoundException("User: " + employeeId + " not found"));

    Poll poll = Poll.builder()
            .pollName(pollRequest.getPollName())
            .content(pollRequest.getContent())
            .uploadData(file.getBytes())
            .fileName(getOriginalFileNameWithoutExtension(file.getOriginalFilename()))
            .fileExtension(getFileExtension(file.getOriginalFilename()))
            .endDate(pollRequest.getEndDate())
            .summary(BigDecimal.ZERO)
            .currentVotesCount(0)
            .minCurrentVotesCount(pollRequest.getMinCurrentVotesCount())
            .minSummary(pollRequest.getMinSummary())
            .user(user)
            .build();

    pollRepository.save(poll);
    return mapPollToPollResponse(poll);
}
\end{lstlisting}

\textbf{Oddawanie głosów} przez właścicieli mieszkań odbywa się za pomocą metody serwisowej \texttt{vote}. Przykładowy fragment kodu:

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Fragment metody \texttt{vote}]
@Override
@Transactional
public VoteResponse vote(UUID pollId, UUID userId, String apartmentSignature, VoteChoice voteChoice) throws UserNotFoundException, PollNotFoundException, ApartmentNotFoundException {
    User user = userRepository.findById(userId)
            .orElseThrow(() -> new UserNotFoundException("User: " + userId + " not found"));

    Poll poll = pollRepository.findById(pollId)
            .orElseThrow(() -> new PollNotFoundException("Poll: " + pollId + " not found"));

    if (voteRepository.existsByPollUuidIDAndApartmentSignature(pollId, apartmentSignature))
        throw new IllegalArgumentException("Vote already exists for apartment");

    Vote vote = Vote.builder()
            .voteChoice(voteChoice)
            .user(user)
            .poll(poll)
            .apartmentSignature(apartmentSignature)
            .build();

    voteRepository.save(vote);
    recalculateSummary(poll);
    return mapVoteToVoteResponse(vote);
}
\end{lstlisting}

\subsection{Osiągnięcia w aktualnym systemie}

W prototypie systemu „Harmony Home Net” udało się zaimplementować:
\begin{itemize}
    \item \textbf{Tworzenie głosowań} -- funkcjonalność pozwala administratorowi na utworzenie głosowania, załączenie dokumentów oraz określenie kworum i minimalnego progu procentowego.
    \item \textbf{Przypomnienia} -- mechanizm harmonogramowania przypomnień dla aktywnych głosowań, wysyłanych jako SMS lub e-mail.
    \item \textbf{Walidacja wyników} -- weryfikacja wyników głosowania pod kątem spełnienia kworum i progu procentowego.
\end{itemize}

\subsection{Braki i aspekty do rozwoju}

Mimo osiągniętych rezultatów, w prototypie nie udało się zrealizować kilku istotnych funkcji lub wymagają one dalszego rozwoju:
\begin{itemize}
    \item \textbf{Pełny interfejs użytkownika} -- brakuje rozbudowanego UI dla właścicieli mieszkań umożliwiającego przeglądanie głosowań i wyników, co jest przestawione na ryusnku~\ref{fig:poll_owner_ui}.
    \item \textbf{Oddawanie głosów} -- mechanizm został zaimplementowany i przetestowany w prostych przypadkach, ale brak UI dla właścicieli może ujawnić potencjalne problemy i aspekty wymagające usprawnienia.
    \item \textbf{Zaawansowane raportowanie} -- aktualnie brak automatycznego generowania szczegółowych raportów wyników głosowań.
    \item \textbf{Integracja z systemami prawnymi} -- nie wdrożono automatycznego przesyłania wyników głosowania do systemów prawnych lub rejestrów.
    \item \textbf{Wsparcie dla różnych scenariuszy głosowania} -- brak obsługi bardziej złożonych mechanizmów liczenia głosów, takich jak podział na grupy czy różne wagi głosów.
\end{itemize}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.63\linewidth]{rys03/poll_ui_unfinish}
    \caption{Aktualny stan UI do głosowani po stonie właściela}
    \label{fig:poll_owner_ui}
\end{figure}

\subsection{Profesjonalne podejście do głosowań}

W profesjonalnym systemie zarządzania głosowaniami proces jest zaprojektowany tak, aby był w pełni zautomatyzowany, przejrzysty i skalowalny. Obejmuje takie funkcje jak:
\begin{itemize}
    \item \textbf{Automatyczne przypomnienia} -- harmonogramowe wysyłanie powiadomień do użytkowników o aktywnych i nadchodzących głosowaniach oraz o ich wynikach. 
    \item \textbf{Zaawansowane scenariusze głosowania} -- obsługa różnych typów głosów (większość kwalifikowana, zwykła), ustalanie indywidualnych progów dla głosowań, dynamiczne dostosowanie mechanizmów liczenia głosów.
    \item \textbf{Generowanie raportów} -- automatyczne tworzenie raportów podsumowujących wyniki głosowania, z podziałem na głosy, osiągnięte kworum oraz spełnienie progu procentowego.
    \item \textbf{Integracja z systemami zewnętrznymi} -- powiązanie wyników głosowań z systemami zarządzania dokumentami, księgowością lub systemami prawnymi, które automatycznie implementują wyniki głosowania (np. rejestracja uchwał w systemie prawnym).
    \item \textbf{Wsparcie dla użytkowników} -- intuicyjny interfejs dla właścicieli mieszkań z możliwością przeglądania wyników, oddawania głosów oraz śledzenia historii głosowań.
\end{itemize}

Rozwinięcie systemu do poziomu profesjonalnego wymagałoby zastosowania diagramów BPMN, które pozwalają na:
\begin{itemize}
    \item Graficzne przedstawienie procesu głosowania, w tym wszystkich zdarzeń, decyzji i przepływów.
    \item Określenie ról i zadań uczestników procesu (administrator, właściciele mieszkań, system powiadomień).
    \item Analizę i optymalizację działania systemu.
\end{itemize}

Dzięki BPMN procesy takie jak tworzenie głosowań, przypomnienia, oddawanie głosów oraz generowanie wyników można dokładnie zaplanować i zaimplementować w sposób efektywny.


\section{Systemy zewnętrzne}

System „Harmony Home Net” wykorzystuje kilka integracji z systemami zewnętrznymi, jednak w prototypie większość funkcjonalności została zaimplementowana jako \emph{mocki}, co oznacza uproszczoną symulację rzeczywistego działania. Poniżej opis poszczególnych integracji oraz ich aktualny stan.

\subsection{System bankowości}

Funkcjonalność płatności w systemie jest realizowana za pomocą klasy \texttt{BankingServiceImp}, która symuluje przesłanie żądania płatności do systemu bankowego. W obecnym stanie logika płatności ogranicza się do wyświetlenia odpowiednich informacji w konsoli, oraz do uproszczonego formularza w UI właściciela, jak przedationo na rysynku~\ref{fig:mock_of_paymet}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.63\linewidth]{rys03/mock_pay}
    \caption{Mock formularza płatności}
    \label{fig:mock_of_paymet}
\end{figure}

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Fragment klasy \texttt{BankingServiceImp}]
@Override
public void pay(BigDecimal amount, String account) {
    LOGGER.info("Paying " + amount + " to " + account);
}
\end{lstlisting}

Pełna integracja z rzeczywistymi systemami bankowymi wymagałaby dostępu do ich API, co zazwyczaj wiąże się z dodatkowymi kosztami i spełnieniem wymagań formalnych (np. certyfikacji)~\cite{paypal_api, stripe_api}.

\subsection{System powiadomień SMS}

Wysyłanie powiadomień SMS jest realizowane przez klasę \texttt{SmsServiceImp}, która również działa jako \emph{mock}. Symuluje wysyłanie SMS-ów, zapisując treść i odbiorcę w logach systemowych:

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Fragment klasy \texttt{SmsServiceImp}]
@Override
@Async
public void sendSms(String text, String recipient) {
    LOG.info("Sending SMS to " + recipient);
    LOG.info("SMS text: " + text);
}
\end{lstlisting}

Dostęp do rzeczywistych usług SMS wymaga skorzystania z zewnętrznych platform, takich jak Twilio czy Clickatell, które są płatne~\cite{twilio, clickatell}.

\subsection{System odczytów liczników mediów}

Odczyty wody i prądu są generowane przez klasę \texttt{UtilityMeterServiceImp}. Zamiast rzeczywistych danych, raz na dobę generowane są losowe wartości:

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Fragment klasy \texttt{UtilityMeterServiceImp}]
@Scheduled(cron = "0 0 0 * * ?")
public void generateRandomMeterReadings() {
    LOG.info("Generating random meter readings");
    waterMeterValue = random.nextDouble() * 1000;
    electricityMeterValue = random.nextDouble() * 1000;
}
\end{lstlisting}

Integracja z rzeczywistymi licznikami wymagałaby dostępu do odpowiednich urządzeń i ich API. Obecnie jest to poza zakresem prototypu.

\subsection{System wysyłania e-maili}

Jedynym w pełni funkcjonalnym systemem zewnętrznym w prototypie jest wysyłanie powiadomień e-mail. Implementacja wykorzystuje usługę \texttt{JavaMailSender}, skonfigurowaną do współpracy z serwerem Gmail:

\begin{lstlisting}[language=Java, style=JavaStyle, caption=Fragment klasy \texttt{MailServiceImp}]
@Override
@Async
public void sendNotificationMail(String subject, String text, String recipient) {
    try {
        MimeMessage message = mailSender.createMimeMessage();
        MimeMessageHelper helper = new MimeMessageHelper(message, true);

        helper.setTo(recipient);
        helper.setFrom(mailFrom, "Harmony Home Net");
        helper.setSubject(subject);
        helper.setText(text, true);

        mailSender.send(message);
    } catch (Exception ex) {
        throw new RuntimeException("Failed to send email", ex);
    }
}
\end{lstlisting}

Wysyłanie e-maili wymaga konfiguracji konta Gmail oraz przestrzegania jego zasad bezpieczeństwa, takich jak generowanie hasła aplikacji~\cite{gmail_api}.

Poniżej znajduje się fragment kodu konfiguracji \texttt{application.yml}, który definiuje ustawienia dla usługi pocztowej w Spring Boot.

\begin{lstlisting}[language=yaml, caption=Fragment konfiguracji poczty w \texttt{application.yml}]
mail:
  host: smtp.gmail.com
  port: 587
  username: # your email
  password: # your password
  properties:
    mail:
      smtp:
        auth: true
        starttls:
          enable: true
\end{lstlisting}

Znaczenie poszczególnych atrybutów w tej konfiguracji jest następujące:
\begin{itemize}
    \item \texttt{host} -- adres serwera SMTP Gmail.
    \item \texttt{port} -- port używany przez serwer SMTP (587 dla połączeń TLS).
    \item \texttt{username} -- adres e-mail nadawcy.
    \item \texttt{password} -- hasło do konta e-mail (zalecane jest korzystanie z haseł aplikacji).
    \item \texttt{auth} -- włączenie uwierzytelniania SMTP.
    \item \texttt{starttls.enable} -- aktywacja szyfrowania TLS.
\end{itemize}
Dzięki tej konfiguracji, wiadomości e-mail mogą być wysyłane bezpośrednio przez serwer Gmail, co zapewnia bezpieczeństwo oraz prostą integrację. W pełnowymiarowej aplikacji zaleca się przechowywanie poufnych danych, takich jak hasła, w zaszyfrowanych menedżerach sekretów 
(np. \emph{HashiCorp Vault} lub \emph{AWS Secrets Manager})~\cite{hashicorp_vault, aws_secret}.


\subsection{Typy powiadomień użytkownika}

Użytkownicy systemu mogą określić preferowany sposób otrzymywania powiadomień za pomocą encji \texttt{NotificationType}. Obsługiwane są dwa typy powiadomień:
\begin{itemize}
    \item \texttt{EMAIL} -- powiadomienia e-mail.
    \item \texttt{SMS} -- powiadomienia SMS (obecnie jako \emph{mock}).
\end{itemize}

Każdy typ powiadomienia przypisany do użytkownika pozwala na indywidualizację komunikacji, ale pełna funkcjonalność wymaga integracji z rzeczywistymi systemami SMS. 


\section{Testy}
W celu zapewnienia wysokiej jakości i niezawodności aplikacji, przeprowadzono testy jednostkowe dla wszystkich głównych serwisów. Testy zostały zorganizowane w osobnym module aplikacji, a ich implementacja oparta jest na frameworku JUnit. Każdy z serwisów został przetestowany pod kątem poprawności działania jego metod oraz obsługi wyjątków.

\subsection{Struktura testów}
Folder \texttt{serviceTests} zawiera testy odpowiadające implementacjom serwisów z folderu \texttt{implementation}. Przykładowo, dla serwisu \texttt{AnnouncementServiceImp} znajduje się plik \texttt{AnnouncementServiceTest.java}. Struktura ta zapewnia klarowność i łatwość w nawigacji pomiędzy kodem implementacji a testami.

\subsection{Zakres testów}
Każdy test obejmuje:
\begin{itemize}
    \item sprawdzenie poprawności logiki biznesowej serwisów,
    \item obsługę przypadków wyjątkowych, takich jak \texttt{AnnouncementNotFoundException}, \texttt{UserNotFoundException}, itp.,
    \item testy graniczne dla danych wejściowych.
\end{itemize}

\subsection{Przykład testów}
Przykładowe testy dla serwisu \texttt{AnnouncementService} weryfikują poprawność różnych funkcjonalności, w tym obsługi wyjątków oraz operacji CRUD. Oto kilka metod testowych:

\begin{lstlisting}[language=Java, style=JavaStyle, caption= Przykłądowe testy dla \texttt{AnnouncementService}]
@Test
void testFindAnnouncementById_NotFound() {
    when(announcementRepository.findById(anyLong())).thenReturn(Optional.empty());
    Assertions.assertThrows(AnnouncementNotFoundException.class, () -> {
        announcementService.findAnnouncementById(1L);
    });
}

@Test
void testCreateAnnouncement_Success() {
    Announcement announcement = new Announcement("New Announcement", "Description");
    when(announcementRepository.save(any(Announcement.class))).thenReturn(announcement);
    Announcement result = announcementService.createAnnouncement(announcement);
    Assertions.assertEquals("New Announcement", result.getTitle());
}

@Test
void testDeleteAnnouncementById_Success() {
    doNothing().when(announcementRepository).deleteById(anyLong());
    Assertions.assertDoesNotThrow(() -> {
        announcementService.deleteAnnouncementById(1L);
    });
}
\end{lstlisting}

% TO DO: jeśli lista wyliczeniowa ma elementy kończące się średnikiem, to powinny one zaczynać się małą literą
Powyższe testy weryfikują: 
\begin{itemize}
    \item wyrzucanie wyjątków, gdy dane wejściowe są nieprawidłowe lub brak jest zasobu w bazie danych,
    \item poprawność zapisu danych do bazy,
    \item skuteczność operacji usuwania rekordów.
\end{itemize}

\subsection{Wyniki testów}
Wszystkie testy jednostkowe zakończyły się pozytywnie, co potwierdza, że zaimplementowane serwisy działają zgodnie z założeniami. Pokrycie testami obejmuje główne przypadki użycia aplikacji. Na rzutach ekranu (rys.~\ref{fig:test_presetation}) widać przykłady 2 serii wykonach testów.

\begin{figure}[htb]
	\centering
		\includegraphics[width=0.91\linewidth]{rys03/testy/platnosci_testy} \\[-1ex]
		\includegraphics[width=0.91\linewidth]{rys03/testy/user_testy} \\[-1ex]
		\caption{Przedstawienie 2 serii testów dla systemu}
	\label{fig:test_presetation}
\end{figure}

